<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liiiyx&#39;s Blog</title>
  
  <subtitle>一如既往, 万事胜意 / 1024199338@qq.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-16T03:23:57.891Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>liiiyx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Emoji表情遇到的手机重启坑</title>
    <link href="http://yoursite.com/2018/01/15/Emoji%E8%A1%A8%E6%83%85%E9%81%87%E5%88%B0%E7%9A%84%E6%89%8B%E6%9C%BA%E9%87%8D%E5%90%AF%E5%9D%91/"/>
    <id>http://yoursite.com/2018/01/15/Emoji表情遇到的手机重启坑/</id>
    <published>2018-01-15T07:18:57.000Z</published>
    <updated>2018-01-16T03:23:57.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在项目上，遇到了编辑指纹名称时输入特殊字符，随后会出现手机重启的奇葩问题。当输入一个emoji表情时，调用Google语音输入法，点击删除键，会出现 � 的非法符号，保存的时候底层检测到该符号为非法符号，会报Exception，导致system server进程直接挂掉，手机就自动重启了。</p><a id="more"></a><p>crash log如下：</p><p><img src="/2018/01/15/Emoji表情遇到的手机重启坑/1.png" alt="crash log信息"></p><h2 id="Unicode和UTF编码的区别"><a href="#Unicode和UTF编码的区别" class="headerlink" title="Unicode和UTF编码的区别"></a>Unicode和UTF编码的区别</h2><p>两者区别如下：</p><ul><li>Unicode：统一的字符编号，仅仅提供字符与编号间的映射；</li><li>UTF：unicode转换格式，定义unicode中编号的编码方式，常见的如UTF-8、UTF-16。UTF-8以8位为单位来标识文字，最大长度为4个字节；UTF-16以16位为单位来标识文字，目前机器的unicode一般指UTF-16，长度可能是2或4个字节。</li></ul><p>在Java的内码（JVM）中，采用UTF-16的方式编码，一般符号（char）是占用2个字节，但随着unicode中字符的增加，2个字节无法表示所有的字符，UTF-16采用了2或4个字节来完成编码。在Java中，采取了一对char来表示那些需要4个字节的字符的方式来解决和兼容该问题。这里可以通过查看Java源码（果然最好的方法是看源码呀），查看CharSequence.java的源码可发现，length()方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the length of this character sequence.  The length is the number</span></span><br><span class="line"><span class="comment"> * of 16-bit &lt;code&gt;char&lt;/code&gt;s in the sequence.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the number of &lt;code&gt;char&lt;/code&gt;s in this sequence</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>由此可知，在Java中char占用2个字节（16 bit）。</p><h2 id="问题具体分析"><a href="#问题具体分析" class="headerlink" title="问题具体分析"></a>问题具体分析</h2><p>回到emoji的问题，经过把EditText的emoji表情String转换成byte数组，打印其length发现，emoji是占用4个字节的（也就是两个char），在Google语音输入法点击删除键时，删除了一个char（具体原因下面有分析），剩下一个char，因“d83d”无法解析，所以显示为我们刚才说的 � 乱码。log信息表格整理如下：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">unicode</th></tr></thead><tbody><tr><td style="text-align:center">字符�</td><td style="text-align:center">高8位：d8，低8位：3d（视emoji最高位字节而定）</td></tr><tr><td style="text-align:center">emoji表情</td><td style="text-align:center">从高到低依次为：d8 3d de 02</td></tr><tr><td style="text-align:center">字符t</td><td style="text-align:center">高8位：0，低8位：74</td></tr></tbody></table><p>转换的方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">convertStr2Unicode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="number">1000</span>);</span><br><span class="line">    String temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        sb.append(<span class="string">"\\u"</span>);</span><br><span class="line">        String high8Bit = Integer.toHexString(c &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">        Log.w(TAG, <span class="string">"convert high 8 bit: "</span> + high8Bit);</span><br><span class="line">        <span class="keyword">if</span> (high8Bit.length() == <span class="number">1</span>)</span><br><span class="line">            sb.append(<span class="string">"0"</span>);</span><br><span class="line">        sb.append(high8Bit);</span><br><span class="line"></span><br><span class="line">        String low8Bit = Integer.toHexString(c &amp; <span class="number">0xFF</span>);</span><br><span class="line">        Log.w(TAG, <span class="string">"convert low 8 bit: "</span> + low8Bit);</span><br><span class="line">        <span class="keyword">if</span> (low8Bit.length() == <span class="number">1</span>)</span><br><span class="line">            sb.append(<span class="string">"0"</span>);</span><br><span class="line">        sb.append(low8Bit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="1-过滤emoji表情"><a href="#1-过滤emoji表情" class="headerlink" title="1. 过滤emoji表情"></a>1. 过滤emoji表情</h3><p>增加指纹名称编辑框的文本过滤，若内容中含有emoji表情的字节码，则判定该文本含有非法字符，继而拦截指纹名称的修改动作。String匹配的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测是否有emoji表情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsEmoji</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> codePoint = source.codePointAt(i);</span><br><span class="line">        <span class="keyword">char</span> c = source.charAt(i);</span><br><span class="line">        Log.d(TAG, <span class="string">"containsEmoji codePoint="</span> + codePoint);</span><br><span class="line">        Log.d(TAG, <span class="string">"containsEmoji char="</span> + c);</span><br><span class="line">        Log.d(TAG, <span class="string">"containsEmoji char's unicode="</span> + convertChar2Unicode(c));</span><br><span class="line">        <span class="keyword">if</span> (isEmojiCharacter(codePoint)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"containsEmoji return="</span> + convertChar2Unicode(c));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmojiCharacter</span><span class="params">(<span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1F30D - 1F567</span></span><br><span class="line"><span class="comment">    1F600 - 1F636</span></span><br><span class="line"><span class="comment">    24C2 - 1F251</span></span><br><span class="line"><span class="comment">    1F680 - 1F6C0</span></span><br><span class="line"><span class="comment">    2702 - 27B0</span></span><br><span class="line"><span class="comment">    1F601 - 1F64F*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !</span><br><span class="line">            ((first == <span class="number">0x0</span>)</span><br><span class="line">            || (first == <span class="number">0x9</span>)</span><br><span class="line">            || (first == <span class="number">0xA</span>)</span><br><span class="line">            || (first == <span class="number">0xD</span>)</span><br><span class="line">            || ((first &gt;= <span class="number">0x20</span>) &amp;&amp; (first &lt;= <span class="number">0xD7FF</span>))</span><br><span class="line">            || ((first &gt;= <span class="number">0xE000</span>) &amp;&amp; (first &lt;= <span class="number">0xFFFD</span>))</span><br><span class="line">            || (first &gt;= <span class="number">0x10000</span>)</span><br><span class="line">            || (first == <span class="number">0xa9</span> || first == <span class="number">0xae</span> || first == <span class="number">0x2122</span> ||</span><br><span class="line">            first == <span class="number">0x3030</span> || (first &gt;= <span class="number">0x25b6</span> &amp;&amp; first &lt;= <span class="number">0x27bf</span>) ||</span><br><span class="line">            first == <span class="number">0x2328</span> || (first &gt;= <span class="number">0x23e9</span> &amp;&amp; first &lt;= <span class="number">0x23fa</span>))</span><br><span class="line">            || ((first &gt;= <span class="number">0x1F000</span> &amp;&amp; first &lt;= <span class="number">0x1FFFF</span>))</span><br><span class="line">            || ((first &gt;= <span class="number">0x2702</span>) &amp;&amp; (first &lt;= <span class="number">0x27B0</span>))</span><br><span class="line">            || ((first &gt;= <span class="number">0x1F601</span>) &amp;&amp; (first &lt;= <span class="number">0x1F64F</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解决方法可以处理特定的场景，但通用性并不强，需要在多个App的界面下进行过滤操作，这不是我们所想要的完美解决方法，所以接下来看一下第二种解决思路。</p><h3 id="2-重写EditText"><a href="#2-重写EditText" class="headerlink" title="2. 重写EditText"></a>2. 重写EditText</h3><p>这个解决思路是在整理这份文章的时候发现的，想着即使没有Google输入法源码，但输入法之类的实现应该跟Input输入系统有关，说不定可以了解到为什么会只删除一个char或者更多信息。奔着这个想法就重新看了下代码，然后惊喜的找到了更好的解决方法！（果然“温故而知新”啊！</p><p>先上一张输入法的框架图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1767465-c2d21a4f651b9667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/690" alt="输入法框架"></p><p>这张图可以提取一下几点信息（在这里感谢下互联网大牛的无私分享）：</p><blockquote><p>两个过程：</p><p>按键消息，由客户端进程接收，如果客户端进程判断当前有输入法窗口，则需要跨进程转交给InputMethod进程<br>触屏消息（触摸在输入法窗口中），由输入法处理，结束后把结果跨进程提交给客户端进程</p><p>四个binder：</p><p>IInputContext：负责InputMethod进程和应用进程的编辑框的通信，如上屏、查询光标前后字符等<br>IInputMethodClient：IMMS使用该接口查找和IMS对应的客户端应用进程，并通知应用进程绑定/解绑输入法。<br>IInputMethodSession：定义了客户端可以调用输入法的相关方法，如updateCursor, finishInput等<br>IInputMethod：负责IMS和IMMS的通信，IMMS通知IMS进行startInput，bindInput等生命周期操作。</p><p>出处：<a href="https://www.jianshu.com/p/eb4ab57393f3" target="_blank" rel="noopener">https://www.jianshu.com/p/eb4ab57393f3</a></p></blockquote><p>这里我们只关注第一点 “<em>按键消息，由客户端进程接收，如果客户端进程判断当前有输入法窗口，则需要跨进程转交给InputMethod进程</em>  “，那么在输入法界面按下删除键，会触发什么KeyEvent呢？我们可以对EditText设置OnKeyListener来监听Key事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">editText.setOnKeyListener(<span class="keyword">new</span> OnKeyListener() &#123;                 </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKey</span><span class="params">(View v, <span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//You can identify which key pressed </span></span><br><span class="line">      <span class="comment">//by checking keyCode value with KeyEvent.KEYCODE_</span></span><br><span class="line">        <span class="keyword">if</span>(keyCode == KeyEvent.KEYCODE_DEL) &#123;  </span><br><span class="line">            Log.w(TAG, <span class="string">"KEYCODE_DEL"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后会发现，Google输入法按下删除键会触发<code>KEYCODE_DEL</code>，而Google语音输入法则不会触发。输入法删除字符时会触发到InputConnection的<code>deleteSurroundingText</code>方法（<a href="http://blog.csdn.net/jianguo_liao19840726/article/details/24714153" target="_blank" rel="noopener">参考</a>），而InputConnection的创建是在View的<code>onCreateInputConnection</code>方法中实现。</p><p>由上可知，删除的操作都围绕着 <strong>InputConnection</strong> 这个类来进行，那么我们就可以通过重写EditText类的<code>onCreateInputConnection</code>方法，创建自己的InputConnection来适配当前的问题场景，让EditText在执行删除操作时发送<code>KEYCODE_DEL</code>事件，响应OnKeyListener事件，问题就得到解决了。</p><p>以下是参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCompatEditText</span> <span class="keyword">extends</span> <span class="title">EditText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MyCompatEditText.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCompatEditText</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCompatEditText</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCompatEditText</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputConnection <span class="title">onCreateInputConnection</span><span class="params">(EditorInfo outAttrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompatInputConnection(<span class="keyword">super</span>.onCreateInputConnection(outAttrs),</span><br><span class="line">                <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CompatInputConnection</span> <span class="keyword">extends</span> <span class="title">InputConnectionWrapper</span> </span>&#123;</span><br><span class="line">        CompatInputConnection(InputConnection target, <span class="keyword">boolean</span> mutable) &#123;</span><br><span class="line">            <span class="keyword">super</span>(target, mutable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"sendKeyEvent keyCode="</span> + event.getKeyCode() </span><br><span class="line">                    + <span class="string">", action="</span> + event.getAction());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.sendKeyEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteSurroundingText</span><span class="params">(<span class="keyword">int</span> beforeLength, <span class="keyword">int</span> afterLength)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"deleteSurroundingText beforeLength="</span> + beforeLength </span><br><span class="line">                    + <span class="string">", afterLength="</span> + afterLength);</span><br><span class="line">            <span class="keyword">if</span> (beforeLength == <span class="number">1</span> &amp;&amp; afterLength == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in latest Android, deleteSurroundingText(1, 0) will be called for backspace</span></span><br><span class="line">                <span class="comment">// 删除emoji表情时，beforeLength == 1 afterLength == 0</span></span><br><span class="line">                sendDownUpKeyEventForBackwardCompatibility(KeyEvent.KEYCODE_DEL);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果去掉上面新增的内容，默认就是走的这里，</span></span><br><span class="line">            <span class="comment">// 就会出现我们所说的emoji只删除一个char，且无法响应OnKeyListener事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.deleteSurroundingText(beforeLength, afterLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送 KEYCODE_DEL 事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDownUpKeyEventForBackwardCompatibility</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> eventTime = SystemClock.uptimeMillis();</span><br><span class="line">            sendKeyEvent(<span class="keyword">new</span> KeyEvent(KeyEvent.ACTION_DOWN,</span><br><span class="line">                    KeyEvent.KEYCODE_DEL));</span><br><span class="line">            <span class="comment">// 这里一定要发送ACTION_UP来通知Input系统事件结束，</span></span><br><span class="line">            <span class="comment">// 否则会在InputEventConsistencyVerifier的onKeyEvent方法中</span></span><br><span class="line">            <span class="comment">// 报出"ACTION_DOWN but key is already down and this event is not a key repeat."</span></span><br><span class="line">            <span class="comment">// 这是不正常的情况</span></span><br><span class="line">            sendKeyEvent(<span class="keyword">new</span> KeyEvent(KeyEvent.ACTION_UP,</span><br><span class="line">                    KeyEvent.KEYCODE_DEL));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路来自：</p><p>Stack Overflow：<a href="https://stackoverflow.com/questions/4886858/android-edittext-deletebackspace-key-event" target="_blank" rel="noopener">Android EditText delete(backspace) key event</a></p><p>cnblogs：<a href="https://www.cnblogs.com/samchen2009/p/3368158.html" target="_blank" rel="noopener">图解Android - Android GUI 系统 (5) - Android的Event Input System</a></p><p>注：EditText中Google原生键盘、华为P9等部分机型上出现的 del键无法响应OnKeyListener事件，也是同样的解法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在项目上，遇到了编辑指纹名称时输入特殊字符，随后会出现手机重启的奇葩问题。当输入一个emoji表情时，调用Google语音输入法，点击删除键，会出现 � 的非法符号，保存的时候底层检测到该符号为非法符号，会报Exception，导致system server进程直接挂掉，手机就自动重启了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>多线程和虚拟机</title>
    <link href="http://yoursite.com/2018/01/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/01/12/多线程和虚拟机/</id>
    <published>2018-01-12T02:56:01.000Z</published>
    <updated>2018-01-12T03:07:01.154Z</updated>
    
    <content type="html"><![CDATA[<p>之前在网上看到的一些关于虚拟机和线程的讲解，讲得比较的通俗易懂，在这里做个整理，方便以后查看。其实理解下来，这些信息都能联系到之前在大学上的操作系统这门课，虚拟机、线程、cpu运行等等，这样理解和延伸就变容易很多了。（现在很后悔当时没好好听课啊。。）</p><a id="more"></a><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>Java程序运行在虚拟机上，而虚拟机又与操作系统打交道，最终通过二进制指令操纵电子电路运行，完成数据的读取、存储、运算和输出。</p><p>虚拟机在加载.class文件是，会在内存开辟一块区域“方法区”，专门用来存储类的基本信息，同时在“堆”区为这些类生成一个Class对象，作为类的镜像或模具，为反射提供基础。程序运行过程中，对象不断地生成和死亡，有的朝生暮死（大部分对象，例如方法内部生成的临时对象），有的壮年而亡，有的长命百岁，有的长生不死除非世界毁灭（虚拟机关闭）。对象生要吃喝死了要埋，所以虚拟机需要不停得去申请内存、回收内存。对象的生成方法有很多，new、反射等，对象回收的方法也很多，GC回收、标记-清除、复制、标记-整理等等。</p><p>垃圾回收，首先我们要知道什么是垃圾、为什么产生、如何回收。我所理解简单的垃圾回收，是后台启动一个线程，设置一定条件（间隔时间、资源阈值等），达到后扫描垃圾对象并清除，然后继续执行原来的程序。如果要更深层的研究，则需要考虑到效率、安全性等因素。举个例子：</p><p>对象生命周期不同，使用同一种回收机制（例如设置间隔时间）这样处理的效率是非常低的，对原程序的运行也会有不可预知的影响。那么我们可以这么改进：</p><ol><li>根据对象的生命周期不同作为一个特性，用来划分不同的运行堆区，每个区采用不同的清理算法；</li><li>根据多核特性，启动多个回收线程一起跑；</li></ol><p>由上述的内容，虚拟机优化就有两个大方向：各个区的大小如何最优划分、GC回收算法如何选择最优，映射到技术层面就是JVM参数调整。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>程序运行的时候，占有cpu和内存资源，而cpu运算的时候需要从内存（很多时候是缓存）取值，然后放入寄存器参与运算，得到结果后先放入寄存器，再放回内存。程序执行的指令集也在放在寄存器中，它记录了当前程序执行的地址。一句话概括就是：程序=数据结构+算法。</p><p>线程执行是语言指令寄存器的，也就是当你切换线程的时候，需要从虚拟机的程序计数器（PC）把该线程的执行指令放到寄存器，当然线程涉及的其他资源也要切换，例如IO设备。这些都是需要耗费资源的，也就是常说的线程的上下文切换。cpu在执行程序的时候，需要准备程序执行指令所需的寄存器的值，以及所涉及的设备（文件系统、网络资源等），所以说线程创建是一个很大的开销，这也就解释了线程是cpu执行的最小单位了。</p><p>延伸一个问题，为什么单线程比多线程快？如上所述线程创建时cpu会分配资源，切换线程时其他资源也需要切换，在单线程模式下，资源都是线程本身的，不存在与其他线程共享与竞争其他资源的情况。</p><h2 id="Java-Thread的start方法和run方法的区别"><a href="#Java-Thread的start方法和run方法的区别" class="headerlink" title="Java Thread的start方法和run方法的区别"></a>Java Thread的start方法和run方法的区别</h2><p>由上述关于多线程的内容可知，start方法会在线程开始执行的时候准备线程所需的资源，而run方法则是相当于普通的方法调用，程序依然运行在主线程中。因此在多线程应用中，调用start方法后，线程必须的资源虚拟机会自动分配，我们所需要关心的只是告诉线程我们想做什么。</p><p>从此我们可以延伸出实现线程的方式：</p><ol><li>继承Thread，重写run方法；</li><li>实现Runnable接口，实现run方法；</li><li>实现Callable接口，回调获取线程结果；</li></ol><p>方法1使用了继承，方法2、3使用了组合，内部持有了所需实现的类，会让程序更加灵活。（这里可以对应到“多用组合少用继承”的开发原则）。</p><h2 id="synchronized关键字与同步机制"><a href="#synchronized关键字与同步机制" class="headerlink" title="synchronized关键字与同步机制"></a>synchronized关键字与同步机制</h2><p>一个数值，进入cpu运算，需要经过内存-&gt;多级缓存-&gt;寄存器。当多线程运算同一个数值是，需要把值从主内存拿到该线程工作的内存单元（寄存器）中，当一个线程计算完毕（CPU会优先把计算结果放到寄存器），还没来得及将数值刷新到主内存，这时候其他线程从主内存取到的是旧值。JVM运行的每个线程都有自己的线程栈，不同线程运行时，都需要复制主内存的一份副本到自身的工作内存。如何保证每个线程拿到的数据都是最新的，这就是同步机制。</p><p>synchronized关键字就是给数据上个锁，共享变量同一时刻只允许一个线程去操作，其他线程必须等待锁释放后才可以进入。这里可以联系到上厕所模型，然后就可以延伸出锁的类型了。</p><p>但有些时候，我们不关心共享值在被谁操作，我们只关心这个值当前是什么。所以就有了volatile。很多博客对该关键词的描述是：保证可见性，不保证原子性。我们来拆解（拆分理解）一下这句话。</p><p>一个共享变量声明为volatile，等于告诉虚拟机控制所有的线程：这个变量有点帅，要请他需要他的老家（主内存）来，回来时也要尽快送回去。所以，CPU计算时从主内存取值，计算完毕后直接存入主内存，不会写到缓存了。这就是所谓的“可见性”，这个值当前是什么，我们是完全知道的。至于原子性，由上可知谁都可以取值来进行运算。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在网上看到的一些关于虚拟机和线程的讲解，讲得比较的通俗易懂，在这里做个整理，方便以后查看。其实理解下来，这些信息都能联系到之前在大学上的操作系统这门课，虚拟机、线程、cpu运行等等，这样理解和延伸就变容易很多了。（现在很后悔当时没好好听课啊。。）&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Camera1架构和ASD流程源码分析</title>
    <link href="http://yoursite.com/2018/01/12/Camera1%E6%9E%B6%E6%9E%84%E5%92%8CASD%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/12/Camera1架构和ASD流程源码分析/</id>
    <published>2018-01-12T01:46:32.000Z</published>
    <updated>2018-01-16T03:14:10.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关文件路径"><a href="#相关文件路径" class="headerlink" title="相关文件路径"></a>相关文件路径</h2><blockquote><p><strong>Java层:</strong><br>/vendor/mediatek/proprietary/packages/apps/Camera/src/</p><ul><li>/com/mediatek/camera/AdditionManager.java</li><li>/com/mediatek/camera/addition/Asd.java</li><li>/com/android/camera/CameraManager.java</li><li>/com/android/camera/AndroidCamera.java</li></ul><p><strong>framework层：</strong><br>/frameworks/av/camera/Camera.cpp<br>/frameworks/av/camera/CameraBase.cpp<br>/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp<br>/frameworks/av/services/camera/libcameraservice/mediatek/api1/CameraClient.cpp<br>/frameworks/base/core/java/android/hardware/Camera.java</p><p><strong>jni层：</strong><br> /frameworks/base/core/jni/android_hardware_Camera.cpp</p><p><strong>Hardware层：</strong><br>vendor/mediatek/proprietary/hardware/mtkcam/</p><ul><li>legacy/platform/mt6735/core/featureio/pipe/aaa/Hal3AAdapter1.cpp</li><li>legacy/platform/mt6735/core/featureio/pipe/asd/asd_hal_base.cpp</li><li>legacy/platform/mt6735/core/featureio/pipe/asd/asd/asd_hal.cpp</li><li>legacy/platform/mt6735/v1/client/CamClient/FD/Asd/AsdClient.cpp</li><li>legacy/platform/mt6735/v1/client/CamClient/FD/FDClient.Thread.cpp</li><li>main/hal/device1/common/Cam1DeviceBase.cpp</li><li>legacy/v1/client/CamClient/CamClient.cpp</li></ul></blockquote><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>最近遇到了ASD(自动场景检测)在室内光线较好的情况下，会选择到夜间模式，需要调整其阈值。于是分析了MTK平台对于Camera1架构的源码实现流程，梳理了ASD的工作流程(App-&gt;framework-&gt;jni-&gt;HAL)，但也仅是对源码流程的一个贯穿，没有对具体实现深入分析。以后若有时间进一步学习，再做补充。</p><p>分析思路：</p><ol><li>先以设置里打开ASD开关为触发点，预览界面/场景检测结果更新为截止点，抓取camera的mtklog；</li><li>检索log的关键信息，找到App层的入口，分析在上层及framework层所做的操作；</li><li>检索log的关键信息，找到HAL层的入口，分析在HAL层的事件处理以及消息传递；</li><li>结合2和3的分析结果，分析framework层与HAL层的jni通信；</li></ol><h2 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h2><p>camera架构图如下：</p><p><img src="https://source.android.com/devices/camera/images/ape_fwk_camera.png" alt="Android 相机架构"></p><blockquote><p><strong>应用框架</strong><br>应用代码位于应用框架级别，它利用 <a href="http://developer.android.com/reference/android/hardware/Camera.html" target="_blank" rel="noopener">android.hardware.Camera</a> API 来与相机硬件互动。在内部，此代码会调用相应的 JNI 粘合类，以访问与该相机互动的原生代码。</p><p><strong>JNI</strong><br>与 <a href="http://developer.android.com/reference/android/hardware/Camera.html" target="_blank" rel="noopener">android.hardware.Camera</a> 关联的 JNI 代码位于 <code>frameworks/base/core/jni/android_hardware_Camera.cpp</code>。此代码会调用较低级别的原生代码以获取对物理相机的访问权限，并返回用于在框架级别创建 <a href="http://developer.android.com/reference/android/hardware/Camera.html" target="_blank" rel="noopener">android.hardware.Camera</a> 对象的数据。</p><p><strong>原生框架</strong><br>在 <code>frameworks/av/camera/Camera.cpp</code> 中定义的原生框架可提供相当于 <a href="http://developer.android.com/reference/android/hardware/Camera.html" target="_blank" rel="noopener">android.hardware.Camera</a> 类的原生类。此类会调用 IPC binder 代理，以获取对相机服务的访问权限。</p><p><strong>Binder IPC 代理</strong><br>IPC binder 代理有助于越过进程边界实现通信。调用相机服务的 <code>frameworks/av/camera</code> 目录中有 3 个相机 binder 类。ICameraService 是相机服务的接口，ICamera 是已打开的特定相机设备的接口，ICameraClient 是返回应用框架的设备接口。</p><p><strong>相机服务</strong><br>位于 <code>frameworks/av/services/camera/libcameraservice/CameraService.cpp</code> 下的相机服务是与 HAL 进行互动的实际代码。</p><p><strong>HAL</strong><br>硬件抽象层定义了由相机服务调用且您必须实现以确保相机硬件正常运行的标准接口。</p><p><strong>内核驱动程序</strong><br>相机的驱动程序可与实际相机硬件和您的 HAL 实现进行互动。相机和驱动程序必须支持 YV12 和 NV21 图片格式，以便在显示和视频录制时支持预览相机图片。</p></blockquote><p>以上信息引用自：<a href="https://source.android.com/devices/camera/" target="_blank" rel="noopener">https://source.android.com/devices/camera/</a> 。接下来顺着Camera1的纵线流程来分析MTK平台上ASD是如何工作的。</p><h2 id="3-启动流程-App、Framework层"><a href="#3-启动流程-App、Framework层" class="headerlink" title="3. 启动流程(App、Framework层)"></a>3. 启动流程(App、Framework层)</h2><h3 id="3-1-启动流程图"><a href="#3-1-启动流程图" class="headerlink" title="3.1 启动流程图"></a>3.1 启动流程图</h3><p><img src="/2018/01/12/Camera1架构和ASD流程源码分析/framework层流程图.png" alt="framework层流程图"></p><p>接下来，从源码来说说这个流程图。</p><h3 id="3-2-AdditionManager-java"><a href="#3-2-AdditionManager-java" class="headerlink" title="3.2 AdditionManager.java"></a>3.2 AdditionManager.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraParameterReady</span><span class="params">(<span class="keyword">boolean</span> isMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数变化时会调用到这里</span></span><br><span class="line">    Log.i(TAG, <span class="string">"[onCameraParameterReady]isMode = "</span> + isMode);</span><br><span class="line">    Vector&lt;ICameraAddition&gt; curAddition = mModeAddition;</span><br><span class="line">    <span class="keyword">if</span> (!isMode) &#123;</span><br><span class="line">        curAddition = mNormalAddition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ICameraAddition addition : curAddition) &#123;</span><br><span class="line">        <span class="comment">// Asd继承自CameraAddition</span></span><br><span class="line">        <span class="comment">// 在这里判断Asd开关是否支持&amp;打开</span></span><br><span class="line">        <span class="keyword">boolean</span> isSupport = addition.isSupport();</span><br><span class="line">        <span class="keyword">boolean</span> isOpen = addition.isOpen();</span><br><span class="line">        <span class="keyword">if</span> (isSupport &amp;&amp; !isOpen) &#123;</span><br><span class="line">        <span class="comment">// 如果支持且开关已打开，则调用Asd的open方法打开Asd模式</span></span><br><span class="line">            addition.open();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isSupport &amp;&amp; isOpen) &#123;</span><br><span class="line">            addition.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Asd-java"><a href="#3-3-Asd-java" class="headerlink" title="3.3 Asd.java"></a>3.3 Asd.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"[open]..."</span>);</span><br><span class="line">    startAsd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAsd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"[startAsd]..."</span>);</span><br><span class="line">    <span class="comment">// 更新当前camera设备实例</span></span><br><span class="line">    updateCameraDevice();</span><br><span class="line">    <span class="keyword">if</span> (mICameraDevice == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里通知framework层做Asd Callback的初始化和设置</span></span><br><span class="line">    <span class="comment">// 用来接收来自HAL层的消息</span></span><br><span class="line">    mICameraDevice.setAsdCallback(mASDCaptureCallback);</span><br><span class="line">    <span class="comment">// 更新ASD状态</span></span><br><span class="line">    mCurrentState = AsdState.STATE_OPENED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-CameraManager-java"><a href="#3-4-CameraManager-java" class="headerlink" title="3.4 CameraManager.java"></a>3.4 CameraManager.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsdCallback</span><span class="params">(AsdListener asdListener)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建AsdListener实例</span></span><br><span class="line">    mCameraDevice.setAsdCallback(asdListener == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> AsdListenerImpl(asdListener));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsdCallback</span><span class="params">(AsdCallback asdCallback)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通知内部类CameraHandler，设置AsdCallback</span></span><br><span class="line">    mCameraHandler.obtainMessage(SET_ASD_CALLBACK, asdCallback).sendToTarget();</span><br><span class="line">    waitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> SET_ASD_CALLBACK:</span><br><span class="line">        <span class="comment">// 这里mCamera是ICamera实例，接口在AndroidCamera中实现</span></span><br><span class="line">        mCamera.setAsdCallback((AsdCallback) msg.obj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-AndroidCamera-java"><a href="#3-5-AndroidCamera-java" class="headerlink" title="3.5 AndroidCamera.java"></a>3.5 AndroidCamera.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsdCallback</span><span class="params">(AsdCallback cb)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用Camera1接口设置Asd的回调</span></span><br><span class="line">    mCamera.setAsdCallback(cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-android-hardware-Camera-java"><a href="#3-6-android-hardware-Camera-java" class="headerlink" title="3.6 android.hardware.Camera.java"></a>3.6 android.hardware.Camera.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Registers a callback to be invoked when auto scene is detected</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cb the callback to run</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAsdCallback</span><span class="params">(AsdCallback cb)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置framework层的AsdCallback回调实例</span></span><br><span class="line">    mAsdCallback = cb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-AsdCallback的创建"><a href="#3-7-AsdCallback的创建" class="headerlink" title="3.7 AsdCallback的创建"></a>3.7 AsdCallback的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Asd.java的内部类，实现了AsdListener接口</span></span><br><span class="line"><span class="comment">// 用于接收来自HAL层的消息，然后通知camera ui做出相应处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsdListener mASDCaptureCallback = <span class="keyword">new</span> AsdListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDeviceCallback</span><span class="params">(<span class="keyword">int</span> scene)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"[onDeviceCallback] onDetected scene = "</span> + scene + <span class="string">","</span> +</span><br><span class="line">                <span class="string">"mLastScene:"</span> + mLastScene);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLastScene != scene) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> suggestedHdr = (scene == SCENE_BACK_LIGHT</span><br><span class="line">                    || scene == SCENE_BACK_LIGHT_PORTRAIT);</span><br><span class="line">            <span class="comment">// 通知camera ui场景的选择结果</span></span><br><span class="line">            mICameraAppUi.onDetectedSceneMode(scene, suggestedHdr);</span><br><span class="line">            mLastScene = scene;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-处理流程及消息回调-Hardware层"><a href="#4-处理流程及消息回调-Hardware层" class="headerlink" title="4. 处理流程及消息回调(Hardware层)"></a>4. 处理流程及消息回调(Hardware层)</h2><p>下面主要讲述在Hardware层，Asd是如何初始化其Client，然后根据camera设备提供的信息进行场景选择，将结果返回给framework层的Camera1，随后传递到上层Camera app的。首先来看看流程图。</p><h3 id="4-1-处理流程图"><a href="#4-1-处理流程图" class="headerlink" title="4.1 处理流程图"></a>4.1 处理流程图</h3><p><img src="/2018/01/12/Camera1架构和ASD流程源码分析/framework层流程图.png" alt="framework层流程图"></p><h3 id="4-2-Hardware层文件说明"><a href="#4-2-Hardware层文件说明" class="headerlink" title="4.2 Hardware层文件说明"></a>4.2 Hardware层文件说明</h3><ul><li><strong>FDClient、AsdClient.cpp :</strong>  Camera的每个feature好像都有一个专属的Client，每个Client又有专属的Client.Thead线程用来处理各类事件；而Asd的场景列表中有人脸模式（在后续的scene decider时也传入了facenum这样的参数）。这里没有进行深入研究，这里就先暂不拓展，因为整个camera架构还是很大的Orz</li><li><strong>asd_hal.cpp :</strong>  该流程的核心成员，主要功能是halASD实例的创建与销毁、ASD的初始化、场景选择。MTK在这里进行ASD各场景的阈值设置，同时分离了一个客制化的配置文件<code>camera_custom_asd.h</code>，客户可在HalAsdInit初始化的时候读取该客制化文件的值，从而客制化修改ASD场景的阈值；</li><li><strong>CameraClient.cpp :</strong>  用以接收来自AsdClient的回调消息；</li><li><strong>Camera.cpp :</strong>  上报回调消息到jni层；</li><li><strong>android_hardware_Camera.cpp :</strong>  jni层的实现</li></ul><h3 id="4-3-FD-Client-Thread-cpp"><a href="#4-3-FD-Client-Thread-cpp" class="headerlink" title="4.3 FD.Client.Thread.cpp"></a>4.3 FD.Client.Thread.cpp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreviewClient的state发生变化时会发送eID_WAKEUP消息</span></span><br><span class="line"><span class="comment">// FDClient应该也会接收到，这里没去细看</span></span><br><span class="line">bool FDClient::threadLoop()</span><br><span class="line">&#123;</span><br><span class="line">    Command::EID cmd;</span><br><span class="line">    <span class="keyword">if</span>  ( getCommand(cmd) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>  (cmd)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> Command::eID_WAKEUP:</span><br><span class="line">            <span class="comment">// 初始化一些Client</span></span><br><span class="line">            onClientThreadLoop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> Command::eID_EXIT:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            MY_LOGD(<span class="string">"Command::%d"</span>, cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FDClient::onClientThreadLoop()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    #if (1 == AUTO_SCENE_DETECT_SUPPORT)</span><br><span class="line">    <span class="comment">//ASD Init</span></span><br><span class="line">    <span class="comment">// 创建AsdClient实例</span></span><br><span class="line">    mpASDClient = IAsdClient::createInstance(mpParamsMgr);</span><br><span class="line">    <span class="comment">// 调用AsdClient的init方法初始化AsdClient</span></span><br><span class="line">    <span class="keyword">if</span>  ( mpASDClient == <span class="number">0</span> || ! mpASDClient-&gt;init() )</span><br><span class="line">    &#123;</span><br><span class="line">        MY_LOGE(<span class="string">"mpASDClient init failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    mpASDClient-&gt;setCallbacks(mpCamMsgCbInfo);</span><br><span class="line">    #endif</span><br><span class="line">    <span class="comment">//(3) Do in loop until stopFaceDetection has been called</span></span><br><span class="line">    <span class="comment">//    either by sendCommand() or by stopPreview()</span></span><br><span class="line">    <span class="keyword">while</span> ( isEnabledState() )</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mpFDHalObj != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// (3.4)</span></span><br><span class="line">          <span class="comment">//performCallback(isDetected_FD, isDetected_SD);</span></span><br><span class="line">          performCallback(isDetected_FD, isDetected_SD, isDetected_GD);</span><br><span class="line"></span><br><span class="line">          #if (1 == AUTO_SCENE_DETECT_SUPPORT)</span><br><span class="line">          <span class="comment">//Call ASD if doFD</span></span><br><span class="line">          <span class="keyword">if</span>(isMsgEnabled())</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">int</span> FaceNum = mpFDHalObj-&gt;halFDGetFaceResult(mpDetectedFaces);</span><br><span class="line">              <span class="comment">// 进行更新操作</span></span><br><span class="line">              <span class="comment">// 这里开始进入到AsdClient的流程(场景选择/消息回调)</span></span><br><span class="line">              mpASDClient-&gt;update(DDPBuffer, srcWidth, srcHeight, FaceNum);</span><br><span class="line">          &#125;</span><br><span class="line">          #endif</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    #if (1 == AUTO_SCENE_DETECT_SUPPORT)</span><br><span class="line">    <span class="keyword">if</span> (mpASDClient != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mpASDClient-&gt;uninit();</span><br><span class="line">        mpASDClient = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-AsdClient-cpp"><a href="#4-4-AsdClient-cpp" class="headerlink" title="4.4 AsdClient.cpp"></a>4.4 AsdClient.cpp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">AsdClient::</span><br><span class="line">update(MUINT8 * OT_Buffer, MINT32 a_Buffer_width, MINT32 a_Buffer_height, MINT32 a_FaceNum)</span><br><span class="line">&#123;</span><br><span class="line">    MUINT32 u4Scene = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ASDInfo_T ASDInfo;</span><br><span class="line">    bool <span class="keyword">const</span> isAsdEnabled = mpParamsMgr-&gt;getShotModeStr() == MtkCameraParameters::CAPTURE_MODE_ASD_SHOT;</span><br><span class="line">    enable(isAsdEnabled);</span><br><span class="line">    <span class="keyword">if</span>  ( ! isEnabled() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Get 3A Info.</span></span><br><span class="line">    MINT32 <span class="keyword">const</span> i4SensorDevId = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Need to be fixed. i4SensorDevId--&gt; i4SensorDevIdIndex, BinChang 2014/01/13</span></span><br><span class="line">    <span class="comment">// 创建一个Hal3AAdapter实例，用以获取ASDInfo</span></span><br><span class="line">    mpHal3A = IHal3A::createInstance(NS3A::IHal3A::E_Camera_1, mpParamsMgr-&gt;getOpenId(), LOG_TAG);</span><br><span class="line">    mpHal3A-&gt;getASDInfo(ASDInfo);</span><br><span class="line">    <span class="keyword">if</span> (mpHal3A)</span><br><span class="line">    &#123;</span><br><span class="line">        mpHal3A-&gt;destroyInstance(LOG_TAG);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Get FD Info.</span></span><br><span class="line">#if(0)</span><br><span class="line">    mpHalFD = halFDBase::createInstance(HAL_FD_OBJ_FDFT_SW);</span><br><span class="line">    mpHalFD-&gt;halFDGetFaceInfo(mpFaceInfo);</span><br><span class="line">    <span class="keyword">if</span>(mpHalFD)</span><br><span class="line">    &#123;</span><br><span class="line">        mpHalFD-&gt;destroyInstance();</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Asd Pipe Init.</span></span><br><span class="line">    <span class="comment">// 初始化Asd管道</span></span><br><span class="line">    <span class="keyword">if</span>(mpHalASDObj == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Set Frame: Prepare QVGA RGB565 resolution</span></span><br><span class="line">        <span class="keyword">if</span>(a_Buffer_width*<span class="number">3</span> == a_Buffer_height*<span class="number">4</span>)</span><br><span class="line">            Buffer_height = <span class="number">240</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a_Buffer_width*<span class="number">9</span> == a_Buffer_height*<span class="number">16</span>)</span><br><span class="line">            Buffer_height = <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a_Buffer_width*<span class="number">3</span> == a_Buffer_height*<span class="number">5</span>)</span><br><span class="line">            Buffer_height = <span class="number">192</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Buffer_height = <span class="number">240</span>;</span><br><span class="line">    <span class="comment">// 创建halAsd实例</span></span><br><span class="line">        mpHalASDObj = halASDBase::createInstance(HAL_ASD_OBJ_AUTO);</span><br><span class="line">        <span class="keyword">if</span>(mpHalASDObj == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            MY_LOGE(<span class="string">"mpHalASDObj createInstance fail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化halAsd实例，这里传入了一个ASDInfo，里面是AWB的一些信息</span></span><br><span class="line">        <span class="comment">// 参数的客制化修改也是在这里进行</span></span><br><span class="line">        mpHalASDObj-&gt;mHalAsdInit((<span class="keyword">void</span>*)&amp;ASDInfo, mpWorkingBuf, (eSensorType==SENSOR_TYPE_RAW)?<span class="number">0</span>:<span class="number">1</span>, Buffer_width/<span class="number">2</span>, Buffer_height/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Asd Pipe Decider</span></span><br><span class="line">    <span class="comment">// 开始场景检测，这里交由mtk封装的camera算法lib库文件处理，结果是返回到mSceneCur</span></span><br><span class="line">    <span class="comment">// 注意这里还传入了一个参数a_FaceNum，所以说FDClient跟AsdClient是有关联的</span></span><br><span class="line">    mpHalASDObj-&gt;mHalAsdDecider((<span class="keyword">void</span>*)&amp;ASDInfo, a_FaceNum ,mSceneCur);</span><br><span class="line">    <span class="comment">//MY_LOGD("ASDInfo.bAEBacklit:%d ", ASDInfo.bAEBacklit);</span></span><br><span class="line">    <span class="comment">//MY_LOGD("mSceneCur:%d ", mSceneCur);</span></span><br><span class="line">    </span><br><span class="line">    u4Scene = mSceneCur;</span><br><span class="line">    </span><br><span class="line">    MY_LOGD(<span class="string">"u4Scene:%d "</span>, u4Scene);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>  (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 消息处理，通知回调函数</span></span><br><span class="line">    <span class="comment">// 这里的mNotifyDb回调函数是在CameraClient的initialize函数里设置了</span></span><br><span class="line">    <span class="comment">// 对应CameraClient的notifyCallback函数，下面的CameraClient章节会说明一下这部分</span></span><br><span class="line">        mpCamMsgCbInfo-&gt;mNotifyCb(</span><br><span class="line">            MTK_CAMERA_MSG_EXT_NOTIFY, <span class="comment">//msgType</span></span><br><span class="line">            MTK_CAMERA_MSG_EXT_NOTIFY_ASD, <span class="comment">//ext1</span></span><br><span class="line">            u4Scene, <span class="comment">//ext2</span></span><br><span class="line">            mpCamMsgCbInfo-&gt;mCbCookie</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MY_LOGD("Buffer_width:%d, Buffer_height:%d,", Buffer_width, Buffer_height);</span></span><br><span class="line">    <span class="comment">// 场景选择后的处理，这里主要是做了一些缓存区的申请</span></span><br><span class="line">    mpHalASDObj-&gt;mHalAsdDoSceneDet((<span class="keyword">void</span>*)OT_Buffer, Buffer_width, Buffer_height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-asd-hal-cpp"><a href="#4-5-asd-hal-cpp" class="headerlink" title="4.5 asd_hal.cpp"></a>4.5 asd_hal.cpp</h3><p>Asd初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">MINT32 halASD::mHalAsdInit(<span class="keyword">void</span>* AAAData,<span class="keyword">void</span>* working_buffer,MUINT8 SensorType, MINT32 Asd_Buf_Width, MINT32 Asd_Buf_Height)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ASD_Customize_PARA1 ASDThres1; <span class="comment">//客制化参数集1</span></span><br><span class="line">    ASD_Customize_PARA2 ASDThres2; <span class="comment">//客制化参数集2</span></span><br><span class="line">    g_udCount++;</span><br><span class="line">    MY_LOGD(<span class="string">"[halASD]  g_udCount++:%d \n"</span>, g_udCount);</span><br><span class="line">    AAA_ASD_PARAM* rASDInfo=(AAA_ASD_PARAM*)AAAData;</span><br><span class="line">    MINT32 Retcode = S_ASD_OK;</span><br><span class="line">    MUINT32* AFtable=(MUINT32*)malloc((rASDInfo-&gt;i4AFTableIdxNum + <span class="number">1</span>)*sizeof(MUINT32));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// debug开关，可通过设置property来打开，从而查看更多log信息</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX] = &#123;<span class="string">'\0'</span>&#125;;</span><br><span class="line">    property_get(<span class="string">"ASD.debug.dump"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    mHalASDDumpOPT = atoi(value);</span><br><span class="line">    </span><br><span class="line">    gMyAsdInitInfo.pInfo = &amp;gMyAsdEnvInfo;</span><br><span class="line">    gMyAsdInitInfo.pDeciderInfo = &amp;gMyDeciderEnvInfo;</span><br><span class="line">    gMyAsdInitInfo.pDeciderTuningInfo = &amp;gMyDeciderTuningInfo;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//这里省略的代码是做gMyAsdInitInfo的一些初始化操作，其中比较关键的是pDeciderInfo的初始化</span></span><br><span class="line">    <span class="comment">//主要是3A中的AWB、AF信息的获取和赋值</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里将pDeciderInfo的指针地址赋值为0了，使用mtk camera算法底层库的默认册数</span></span><br><span class="line">    <span class="comment">//如果需要对ASD的的参数进行客制化修改，需要注释掉这里</span></span><br><span class="line">    <span class="comment">//不然在客制化赋值的时候会找不到正确的内存地址，而导致修改无效</span></span><br><span class="line">    gMyAsdInitInfo.pDeciderTuningInfo = <span class="number">0</span>;                        <span class="comment">// use default value</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  Create MTKPano Interface  */</span></span><br><span class="line">    <span class="comment">//m_pMTKAsdObj用于调用底层库方法</span></span><br><span class="line">    <span class="keyword">if</span>(m_pMTKAsdObj == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pMTKAsdObj = MTKAsd::createInstance(DRV_ASD_OBJ_SW);</span><br><span class="line">        MY_LOGW_IF(m_pMTKAsdObj == NULL, <span class="string">"Err"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客制化参数的获取和设置</span></span><br><span class="line"><span class="comment">//if (0)默认不编译，如果需要进行客制化修改，这里需要改成if (1)</span></span><br><span class="line">#if (0)</span><br><span class="line"><span class="comment">//从camera_custom.h中获取客制化参数集</span></span><br><span class="line">    get_asd_CustomizeData1(&amp;ASDThres1);</span><br><span class="line">    get_asd_CustomizeData2(&amp;ASDThres2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//客制化参数设置</span></span><br><span class="line">    gMyAsdInitInfo.pDeciderTuningInfo-&gt;IdxWeightBlAe = ASDThres2.s2IdxWeightBlAe;</span><br><span class="line">    ...</span><br><span class="line">    gMyAsdInitInfo.pDeciderTuningInfo-&gt;EvLoThrNight = ASDThres2.s2EvLoThrNight;</span><br><span class="line">    gMyAsdInitInfo.pDeciderTuningInfo-&gt;EvHiThrNight = ASDThres2.s2EvHiThrNight;</span><br><span class="line">    ...</span><br><span class="line">    gMyAsdInitInfo.pDeciderTuningInfo-&gt;ScoreThrNight = ASDThres1.u1ScoreThrNight;</span><br><span class="line">    ...</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">//初始化Asd</span></span><br><span class="line">    m_pMTKAsdObj-&gt;AsdInit(&amp;gMyAsdInitInfo, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AFtable) &#123;</span><br><span class="line">        free(AFtable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Retcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Asd场景检测：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MINT32 halASD::mHalAsdDecider(<span class="keyword">void</span>* AAAData,MINT32 Face_Num,mhal_ASD_DECIDER_UI_SCENE_TYPE_ENUM &amp;Scene)</span><br><span class="line">&#123;</span><br><span class="line">      MINT32 Retcode = S_ASD_OK;</span><br><span class="line">      AAA_ASD_PARAM* rASDInfo=(AAA_ASD_PARAM*)AAAData;</span><br><span class="line">      ASD_DECIDER_RESULT_STRUCT MyDeciderResult;</span><br><span class="line">      ASD_SCD_RESULT_STRUCT gMyAsdResultInfo;</span><br><span class="line">      ASD_DECIDER_INFO_STRUCT gMyDeciderInfo;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//设置gMyDeciderInfo的Fd(人脸检测)、3A(AE&amp;AWB&amp;AF)信息</span></span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 这里的m_pMTKAsdObj在Asd init的时候创建了，用以调用MTK底层库封装的函数</span></span><br><span class="line">      <span class="comment">// AsdFeatureCtrl、AsdMain这两个函数的实现是在/vendor/xxx/libs中</span></span><br><span class="line">      <span class="comment">// 可以通过 grep 关键字 来检索</span></span><br><span class="line">      m_pMTKAsdObj-&gt;AsdFeatureCtrl(ASD_FEATURE_GET_RESULT, <span class="number">0</span>, &amp;gMyAsdResultInfo);</span><br><span class="line">      memcpy(&amp;(gMyDeciderInfo.InfoScd),&amp;gMyAsdResultInfo, sizeof(ASD_SCD_RESULT_STRUCT));</span><br><span class="line">      m_pMTKAsdObj-&gt;AsdMain(ASD_PROC_DECIDER, &amp;gMyDeciderInfo);</span><br><span class="line">      m_pMTKAsdObj-&gt;AsdFeatureCtrl(DECIDER_FEATURE_GET_RESULT, <span class="number">0</span>, &amp;MyDeciderResult);</span><br><span class="line">      MY_LOGD(<span class="string">"[mHalAsdDecider] detect Scene is %d, Face Num:%d \n"</span>,MyDeciderResult.DeciderUiScene, gMyDeciderInfo.InfoFd.FdFaceNum);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 得到场景检测的结果</span></span><br><span class="line">      Scene=(mhal_ASD_DECIDER_UI_SCENE_TYPE_ENUM) MyDeciderResult.DeciderUiScene;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//Scene=mhal_ASD_DECIDER_UI_AUTO;</span></span><br><span class="line">      <span class="keyword">return</span> Retcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-6-CameraClient-cpp"><a href="#4-6-CameraClient-cpp" class="headerlink" title="4.6 CameraClient.cpp"></a>4.6 CameraClient.cpp</h3><p>首先先来说说AsdClient中提到的mNotifyCb函数，这个函数是在CameraClient的initialize函数中被定义的。我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraClient::initialize(CameraModule *<span class="keyword">module</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mHardware = <span class="keyword">new</span> CameraHardwareInterface(camera_device_name);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用的是Cam1DeviceBase的setCallback()函数</span></span><br><span class="line">    mHardware-&gt;setCallbacks(notifyCallback,</span><br><span class="line">            dataCallback,</span><br><span class="line">            dataCallbackTimestamp,</span><br><span class="line">            (<span class="keyword">void</span> *)(uintptr_t)mCameraId);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们看看Cam1DeviceBase setCallback函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the notification and data callbacks</span></span><br><span class="line"><span class="keyword">void</span> Cam1DeviceBase::setCallbacks(</span><br><span class="line">    camera_notify_callback notify_cb, <span class="comment">//notify Callback函数</span></span><br><span class="line">    camera_data_callback data_cb, <span class="comment">//data Callback函数</span></span><br><span class="line">    camera_data_timestamp_callback data_cb_timestamp,</span><br><span class="line">    camera_request_memory get_memory,</span><br><span class="line">    <span class="keyword">void</span>*user</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    mpCamMsgCbInfo-&gt;mCbCookie       = user;</span><br><span class="line">    mpCamMsgCbInfo-&gt;mNotifyCb       = notify_cb; <span class="comment">//mNotifyCb函数赋值</span></span><br><span class="line">    mpCamMsgCbInfo-&gt;mDataCb         = data_cb;   <span class="comment">//mDataCb函数赋值</span></span><br><span class="line">    mpCamMsgCbInfo-&gt;mDataCbTimestamp= data_cb_timestamp;</span><br><span class="line">    mpCamMsgCbInfo-&gt;mRequestMemory  = get_memory;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>  ( mpCamClient != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        mpCamClient-&gt;setCallbacks(mpCamMsgCbInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// forward to registered clients</span></span><br><span class="line">    Vector&lt;sp&lt;ICamClient&gt; &gt;::const_iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = vmpCamClient.begin(); it != vmpCamClient.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        (*it)-&gt;setCallbacks(mpCamMsgCbInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>  ( mpCamAdapter != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        mpCamAdapter-&gt;setCallbacks(mpCamMsgCbInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才我们分析到AsdClient在进行场景检测得到结果后，调用了mNotifyCb函数；根据上面的分析，mNotifyCb函数指向CameraClient的notifyCallback函数，来看看该函数的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callback messages can be dispatched to internal handlers or pass to our</span></span><br><span class="line"><span class="comment">// client's callback functions, depending on the message type.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// notifyCallback:</span></span><br><span class="line"><span class="comment">//      CAMERA_MSG_SHUTTER              handleShutter</span></span><br><span class="line"><span class="comment">//      (others)                        c-&gt;notifyCallback</span></span><br><span class="line"><span class="comment">// dataCallback:</span></span><br><span class="line"><span class="comment">//      CAMERA_MSG_PREVIEW_FRAME        handlePreviewData</span></span><br><span class="line"><span class="comment">//      CAMERA_MSG_POSTVIEW_FRAME       handlePostview</span></span><br><span class="line"><span class="comment">//      CAMERA_MSG_RAW_IMAGE            handleRawPicture</span></span><br><span class="line"><span class="comment">//      CAMERA_MSG_COMPRESSED_IMAGE     handleCompressedPicture</span></span><br><span class="line"><span class="comment">//      (others)                        c-&gt;dataCallback</span></span><br><span class="line"><span class="comment">// dataCallbackTimestamp</span></span><br><span class="line"><span class="comment">//      (others)                        c-&gt;dataCallbackTimestamp</span></span><br><span class="line"><span class="keyword">void</span> CameraClient::notifyCallback(int32_t msgType, int32_t ext1,</span><br><span class="line">        int32_t ext2, <span class="keyword">void</span>* user) &#123;</span><br><span class="line">    LOG2(<span class="string">"notifyCallback(%d)"</span>, msgType);</span><br><span class="line"></span><br><span class="line">    sp&lt;CameraClient&gt; client = static_cast&lt;CameraClient*&gt;(getClientFromCookie(user).get());</span><br><span class="line">    <span class="keyword">if</span> (client.get() == nullptr) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client-&gt;lockIfMessageWanted(msgType)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msgType) &#123;</span><br><span class="line">        <span class="comment">//!++</span></span><br><span class="line">        <span class="keyword">case</span> MTK_CAMERA_MSG_EXT_NOTIFY:</span><br><span class="line">            client-&gt;handleMtkExtNotify(ext1, ext2); <span class="comment">// Callback extended msg notification.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//!--</span></span><br><span class="line">        <span class="keyword">case</span> CAMERA_MSG_SHUTTER:</span><br><span class="line">            <span class="comment">// ext1 is the dimension of the yuv picture.</span></span><br><span class="line">            client-&gt;handleShutter();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            client-&gt;handleGenericNotify(msgType, ext1, ext2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mNotifyCb函数调用传入的msgType是<code>MTK_CAMERA_MSG_EXT_NOTIFY</code> ，那么接下来会执行到<code>handleMtkExtNotify</code>，该函数在Mediatek自己写的CameraClient.cpp中实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CameraClient::handleMtkExtNotify(int32_t ext1, int32_t ext2)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t <span class="keyword">const</span> extMsgType = ext1;</span><br><span class="line">    <span class="keyword">switch</span>  (extMsgType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE:</span><br><span class="line">        handleMtkExtCaptureDone(ext1, ext2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">case</span> MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER:</span><br><span class="line">        handleMtkExtShutter(ext1, ext2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">case</span> MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER:</span><br><span class="line">        handleMtkExtBurstShutter(ext1, ext2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER:</span><br><span class="line">        handleMtkExtContinuousShutter(ext1, ext2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END:</span><br><span class="line">        handleMtkExtContinuousEnd(ext1, ext2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传入的ext1为<code>MTK_CAMERA_MSG_EXT_NOTIFY_ASD</code>，所以又走回Android原生 CameraClient 的handleGenericNotify函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CameraClient::handleGenericNotify(int32_t msgType,</span><br><span class="line">    int32_t ext1, int32_t ext2) &#123;</span><br><span class="line">    <span class="comment">//!++</span></span><br><span class="line">    #ifdef MTK_CAM_FRAMEWORK_DEFAULT_CODE</span><br><span class="line">    <span class="comment">//!--</span></span><br><span class="line">    sp&lt;hardware::ICameraClient&gt; c = mRemoteCallback;</span><br><span class="line">    <span class="comment">//!++</span></span><br><span class="line">    #else</span><br><span class="line">    sp&lt;hardware::ICameraClient&gt; c;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">remoteCallbacklock</span><span class="params">(mRemoteCallbackLock)</span></span>;</span><br><span class="line">        c = mRemoteCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line">    <span class="comment">//!--</span></span><br><span class="line">    <span class="comment">//!++ There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.</span></span><br><span class="line">    #ifdef MTK_CAM_FRAMEWORK_DEFAULT_CODE</span><br><span class="line">    mLock.unlock();</span><br><span class="line">    #endif</span><br><span class="line">    <span class="comment">//!--</span></span><br><span class="line">    <span class="comment">// 除了notifyCallback这种方式，在看Preview流程时还有一种方式是</span></span><br><span class="line">    <span class="comment">// copy当前帧然后把copy后的数据直接发送出去</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;notifyCallback(msgType, ext1, ext2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上可知消息是通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;hardware::ICameraClient&gt; c = mRemoteCallback; </span><br><span class="line">c-&gt;notifyCallback(msgType, ext1, ext2);</span><br></pre></td></tr></table></figure></p><p>的方式发送出去的。</p><p>那这个mRemoteCallback又是在哪里初始化的呢？检索了一下，是在CameraClient::connect中被赋值了，继续跟踪下去，会发现是在CameraClient的构造函数里初始化的，这里涉及到了多层继承(CameraClient-&gt;CameraService-&gt;Client)，看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">step1：</span><br><span class="line">CameraClient::CameraClient(<span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;hardware::ICameraClient&gt;&amp; cameraClient, <span class="comment">// 这里传入了一个ICameraClient</span></span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">int</span> cameraId, <span class="keyword">int</span> cameraFacing,</span><br><span class="line">        <span class="keyword">int</span> clientPid, <span class="keyword">int</span> clientUid,</span><br><span class="line">        <span class="keyword">int</span> servicePid, bool legacyMode):</span><br><span class="line">        <span class="comment">// 这里开始调用Client的构造函数，传入一个cameraClient参数</span></span><br><span class="line">        <span class="comment">// Client是CameraService底下的一个内部类</span></span><br><span class="line">        Client(cameraService, cameraClient, clientPackageName,</span><br><span class="line">                cameraId, cameraFacing, clientPid, clientUid, servicePid)</span><br><span class="line">                </span><br><span class="line">step2：</span><br><span class="line">CameraService::Client::Client(<span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ICameraClient&gt;&amp; cameraClient,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">int</span> cameraId, <span class="keyword">int</span> cameraFacing,</span><br><span class="line">        <span class="keyword">int</span> clientPid, uid_t clientUid,</span><br><span class="line">        <span class="keyword">int</span> servicePid) :</span><br><span class="line">        CameraService::BasicClient(cameraService,</span><br><span class="line">                IInterface::asBinder(cameraClient),</span><br><span class="line">                clientPackageName,</span><br><span class="line">                cameraId, cameraFacing,</span><br><span class="line">                clientPid, clientUid,</span><br><span class="line">                servicePid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> callingPid = getCallingPid();</span><br><span class="line">    LOG1(<span class="string">"Client::Client E (pid %d, id %d)"</span>, callingPid, cameraId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里对mRemoteCallback进行了赋值初始化</span></span><br><span class="line">    mRemoteCallback = cameraClient;</span><br><span class="line"></span><br><span class="line">    cameraService-&gt;loadSound();</span><br><span class="line">    LOG1(<span class="string">"Client::Client X (pid %d, id %d)"</span>, callingPid, cameraId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么思路就清晰了，我们只需要看一下这个CameraClient进行了初始化就可以了。从Camera的connect方法看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">step <span class="number">1</span>：</span><br><span class="line">sp&lt;Camera&gt; Camera::connect(<span class="keyword">int</span> cameraId, <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">int</span> clientUid, <span class="keyword">int</span> clientPid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// CameraBaseT在CameraBase中被定义：typedef CameraBase&lt;TCam&gt; CameraBaseT</span></span><br><span class="line"><span class="comment">// CameraBase在Camera被初始化为CameraBase&lt;Camera&gt;，所以上面就相应于调用了</span></span><br><span class="line"><span class="comment">// CameraBase&lt;Camera&gt;::connect()</span></span><br><span class="line">    <span class="keyword">return</span> CameraBaseT::connect(cameraId, clientPackageName, clientUid, clientPid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step <span class="number">2</span>：</span><br><span class="line">template &lt;typename TCam, typename TCamTraits&gt;</span><br><span class="line">sp&lt;TCam&gt; CameraBase&lt;TCam, TCamTraits&gt;::connect(<span class="keyword">int</span> cameraId,</span><br><span class="line">                                               <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">                                               <span class="keyword">int</span> clientUid, <span class="keyword">int</span> clientPid)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"%s: connect"</span>, __FUNCTION__);</span><br><span class="line">    <span class="comment">// 构造Camera实例</span></span><br><span class="line">    sp&lt;TCam&gt; c = <span class="keyword">new</span> TCam(cameraId);</span><br><span class="line">    <span class="comment">// TCamCallbacks在Camera.h中被定义为ICameraClient</span></span><br><span class="line">    <span class="comment">// 这里cl = c被赋值为Camera类型，而Camera继承了ICameraClient</span></span><br><span class="line">    sp&lt;TCamCallbacks&gt; cl = c;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;::android::hardware::ICameraService&gt; cs = getCameraService();</span><br><span class="line"></span><br><span class="line">    binder::Status ret;</span><br><span class="line">    <span class="keyword">if</span> (cs != nullptr) &#123;</span><br><span class="line">    <span class="comment">// fnConnectService在Camera被初始化为ICameraService::connect()</span></span><br><span class="line">        TCamConnectService fnConnectService = TCamTraits::fnConnectService;</span><br><span class="line">        <span class="comment">// 这里调用了CameraService::connect() c和cl是同一个值，做为两个不同的参数传进了</span></span><br><span class="line">        <span class="comment">// CameraService::connect()</span></span><br><span class="line">        ret = (cs.get()-&gt;*fnConnectService)(cl, cameraId, clientPackageName, clientUid,</span><br><span class="line">                                               clientPid, <span class="comment">/*out*/</span> &amp;c-&gt;mCamera);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step <span class="number">3</span>：</span><br><span class="line"><span class="comment">// CameraService::connec()构造了一个CameraClient(),又是一个CameraClient，</span></span><br><span class="line"><span class="comment">// 但是和上面的ICameraClient没有半毛线关系。只是名字相似,真的是一万个++泥马在奔腾。</span></span><br><span class="line">status_t CameraService::connect(<span class="keyword">const</span> sp&lt;ICameraClient&gt;&amp; cameraClient, <span class="keyword">int</span> cameraId,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName, <span class="keyword">int</span> clientUid, <span class="comment">/*out*/</span>sp&lt;ICamera&gt;&amp; device) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CameraService::connect()就做了两件事情</span></span><br><span class="line"><span class="comment">// 初始化Camera里的mCamera和把Camera(参数cameraClient为Camera类型)传给CameraClient</span></span><br><span class="line"><span class="comment">// 由上面的分析我们知道CameraClient的构造函数最后会走到CameraService中的Client构造函数</span></span><br><span class="line"><span class="comment">// 所以说，Camera类就是mRemoteCallback</span></span><br><span class="line">    client = <span class="keyword">new</span> CameraClient(<span class="keyword">this</span>, cameraClient, clientPackageName, cameraId,</span><br><span class="line">                    facing, callingPid, clientUid, getpid());</span><br><span class="line">        </span><br><span class="line">    device = client;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，使用的c-&gt;notifyCallback调用的是<code>Camera::notifyCallback</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback from camera service</span></span><br><span class="line"><span class="keyword">void</span> Camera::notifyCallback(int32_t msgType, int32_t ext1, int32_t ext2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> CameraBaseT::notifyCallback(msgType, ext1, ext2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename TCam, typename TCamTraits&gt;</span><br><span class="line"><span class="keyword">void</span> CameraBase&lt;TCam, TCamTraits&gt;::notifyCallback(int32_t msgType, int32_t ext1, int32_t ext2)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;TCamListener&gt; listener;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        listener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener != NULL) &#123;</span><br><span class="line">        listener-&gt;notify(msgType, ext1, ext2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的mListener是在android_hardware_Camera.cpp被设置，接下来我们进入到JNI层(终于快到Java层了^^)。</p><h2 id="5-消息上报-jni层"><a href="#5-消息上报-jni层" class="headerlink" title="5. 消息上报(jni层)"></a>5. 消息上报(jni层)</h2><p>首先我们先看一下mListener的设置代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_hardware_Camera_native_setup</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;Camera&gt; camera;</span><br><span class="line">    sp&lt;JNICameraContext&gt; context = <span class="keyword">new</span> MtkJNICameraContext(env, weak_this, clazz, camera);</span><br><span class="line">    <span class="comment">// 设置mListener，类型为MtkJNICameraContext</span></span><br><span class="line">    camera-&gt;setListener(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以listener-&gt;notify调用的是<code>MtkJNICameraContext::notify</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JNICameraContext::notify(int32_t msgType, int32_t ext1, int32_t ext2)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"notify"</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里的post_event在android_hardware_Camera.cpp中有被定义postEventFromNative()</span></span><br><span class="line">    <span class="comment">// 所以会调用到frameworks/base/core/java/android/hardware/Camera.java的</span></span><br><span class="line">    <span class="comment">// postEventFromNative方法</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(mCameraJClass, fields.post_event,</span><br><span class="line">            mCameraJObjectWeak, msgType, ext1, ext2, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jclass clazz = FindClassOrDie(env, <span class="string">"android/hardware/Camera"</span>);</span><br><span class="line">fields.post_event = GetStaticMethodIDOrDie(env, clazz, <span class="string">"postEventFromNative"</span>,</span><br><span class="line">                                               <span class="string">"(Ljava/lang/Object;IIILjava/lang/Object;)V"</span>);</span><br></pre></td></tr></table></figure></p><p>那么我们来看一下Camera.java中做了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postEventFromNative</span><span class="params">(Object camera_ref,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Camera c = (Camera)((WeakReference)camera_ref).get();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c.mEventHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Message m = c.mEventHandler.obtainMessage(what, arg1, arg2, obj);</span><br><span class="line">        <span class="comment">// 这里把hardware层上来的消息发送出去了，在Camera的内部类EventHandler中处理</span></span><br><span class="line">        c.mEventHandler.sendMessage(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> MTK_CAMERA_MSG_EXT_NOTIFY:</span><br><span class="line">    <span class="keyword">case</span> MTK_CAMERA_MSG_EXT_NOTIFY_ASD:</span><br><span class="line">                    <span class="keyword">if</span> (mAsdCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 这里回调到Asd中声明的AsdCallback里</span></span><br><span class="line">                        mAsdCallback.onDetected(msg.arg2);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，到这里消息在JNI层是如何被处理、上报到framework再到App就结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关文件路径&quot;&gt;&lt;a href=&quot;#相关文件路径&quot; class=&quot;headerlink&quot; title=&quot;相关文件路径&quot;&gt;&lt;/a&gt;相关文件路径&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Java层:&lt;/strong&gt;&lt;br&gt;/vendor/mediat
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Camera" scheme="http://yoursite.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://yoursite.com/2018/01/11/Hello%20Hexo/"/>
    <id>http://yoursite.com/2018/01/11/Hello Hexo/</id>
    <published>2018-01-11T06:34:08.820Z</published>
    <updated>2018-01-11T06:47:02.338Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理有道笔记的内容，平常都是做伸手党，在互联网各位大神的肩膀上分析/解决问题，于是就想以博客的形式输出一些内容，主要是<strong>Android系统源码</strong>方面的，希望能在积累沉淀自己的同时，帮助到一些遇到了类似问题的人。可能会偶尔发表自己的一些生活感想，就当是日记记录吧。</p><p>作为一个程序员，本着亲自动手的想法，博客当然是想自己搭建了，所以查询了相关资料，折腾了一个上午总算搭建好了。（使用Github + Hexo的方式）</p><p>教程链接：</p><p><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">Mac</a></p><p><a href="http://blog.csdn.net/wapchief/article/details/54602515" target="_blank" rel="noopener">Windows</a></p><p>Hello Hexo，第一篇章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在整理有道笔记的内容，平常都是做伸手党，在互联网各位大神的肩膀上分析/解决问题，于是就想以博客的形式输出一些内容，主要是&lt;strong&gt;Android系统源码&lt;/strong&gt;方面的，希望能在积累沉淀自己的同时，帮助到一些遇到了类似问题的人。可能会偶尔发表自己的一些生活
      
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
