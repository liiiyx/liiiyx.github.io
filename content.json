{"meta":{"title":"liiiyx's Blog","subtitle":"一如既往, 万事胜意 / 1024199338@qq.com","description":null,"author":"liiiyx","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-01-11T07:05:28.000Z","updated":"2018-01-11T07:06:31.023Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Email：1024199338@qq.com PS：一只搞Android/爱摄影/爱模型的程序猿"}],"posts":[{"title":"Emoji表情遇到的手机重启坑","slug":"Emoji表情遇到的手机重启坑","date":"2018-01-15T07:18:57.000Z","updated":"2018-01-16T03:23:57.891Z","comments":true,"path":"2018/01/15/Emoji表情遇到的手机重启坑/","link":"","permalink":"http://yoursite.com/2018/01/15/Emoji表情遇到的手机重启坑/","excerpt":"问题描述在项目上，遇到了编辑指纹名称时输入特殊字符，随后会出现手机重启的奇葩问题。当输入一个emoji表情时，调用Google语音输入法，点击删除键，会出现 � 的非法符号，保存的时候底层检测到该符号为非法符号，会报Exception，导致system server进程直接挂掉，手机就自动重启了。","text":"问题描述在项目上，遇到了编辑指纹名称时输入特殊字符，随后会出现手机重启的奇葩问题。当输入一个emoji表情时，调用Google语音输入法，点击删除键，会出现 � 的非法符号，保存的时候底层检测到该符号为非法符号，会报Exception，导致system server进程直接挂掉，手机就自动重启了。 crash log如下： Unicode和UTF编码的区别两者区别如下： Unicode：统一的字符编号，仅仅提供字符与编号间的映射； UTF：unicode转换格式，定义unicode中编号的编码方式，常见的如UTF-8、UTF-16。UTF-8以8位为单位来标识文字，最大长度为4个字节；UTF-16以16位为单位来标识文字，目前机器的unicode一般指UTF-16，长度可能是2或4个字节。 在Java的内码（JVM）中，采用UTF-16的方式编码，一般符号（char）是占用2个字节，但随着unicode中字符的增加，2个字节无法表示所有的字符，UTF-16采用了2或4个字节来完成编码。在Java中，采取了一对char来表示那些需要4个字节的字符的方式来解决和兼容该问题。这里可以通过查看Java源码（果然最好的方法是看源码呀），查看CharSequence.java的源码可发现，length()方法的定义如下： 1234567/** * Returns the length of this character sequence. The length is the number * of 16-bit &lt;code&gt;char&lt;/code&gt;s in the sequence.&lt;/p&gt; * * @return the number of &lt;code&gt;char&lt;/code&gt;s in this sequence */int length(); 由此可知，在Java中char占用2个字节（16 bit）。 问题具体分析回到emoji的问题，经过把EditText的emoji表情String转换成byte数组，打印其length发现，emoji是占用4个字节的（也就是两个char），在Google语音输入法点击删除键时，删除了一个char（具体原因下面有分析），剩下一个char，因“d83d”无法解析，所以显示为我们刚才说的 � 乱码。log信息表格整理如下： 字符 unicode 字符� 高8位：d8，低8位：3d（视emoji最高位字节而定） emoji表情 从高到低依次为：d8 3d de 02 字符t 高8位：0，低8位：74 转换的方法代码如下： 123456789101112131415161718192021222324private String convertStr2Unicode(String str) &#123; if (str == null) return \"\"; StringBuffer sb = new StringBuffer(1000); String temp; for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); sb.append(\"\\\\u\"); String high8Bit = Integer.toHexString(c &gt;&gt;&gt; 8); Log.w(TAG, \"convert high 8 bit: \" + high8Bit); if (high8Bit.length() == 1) sb.append(\"0\"); sb.append(high8Bit); String low8Bit = Integer.toHexString(c &amp; 0xFF); Log.w(TAG, \"convert low 8 bit: \" + low8Bit); if (low8Bit.length() == 1) sb.append(\"0\"); sb.append(low8Bit); &#125; return new String(sb);&#125; 解决思路1. 过滤emoji表情增加指纹名称编辑框的文本过滤，若内容中含有emoji表情的字节码，则判定该文本含有非法字符，继而拦截指纹名称的修改动作。String匹配的方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 检测是否有emoji表情 */public static boolean containsEmoji(String source) &#123; if (source == null) &#123; return false; &#125; for (int i = 0; i &lt; source.length(); i++) &#123; int codePoint = source.codePointAt(i); char c = source.charAt(i); Log.d(TAG, \"containsEmoji codePoint=\" + codePoint); Log.d(TAG, \"containsEmoji char=\" + c); Log.d(TAG, \"containsEmoji char's unicode=\" + convertChar2Unicode(c)); if (isEmojiCharacter(codePoint)) &#123; Log.e(TAG, \"containsEmoji return=\" + convertChar2Unicode(c)); return true; &#125; &#125; return false;&#125;private static boolean isEmojiCharacter(int first) &#123; /* 1F30D - 1F567 1F600 - 1F636 24C2 - 1F251 1F680 - 1F6C0 2702 - 27B0 1F601 - 1F64F*/ return ! ((first == 0x0) || (first == 0x9) || (first == 0xA) || (first == 0xD) || ((first &gt;= 0x20) &amp;&amp; (first &lt;= 0xD7FF)) || ((first &gt;= 0xE000) &amp;&amp; (first &lt;= 0xFFFD)) || (first &gt;= 0x10000) || (first == 0xa9 || first == 0xae || first == 0x2122 || first == 0x3030 || (first &gt;= 0x25b6 &amp;&amp; first &lt;= 0x27bf) || first == 0x2328 || (first &gt;= 0x23e9 &amp;&amp; first &lt;= 0x23fa)) || ((first &gt;= 0x1F000 &amp;&amp; first &lt;= 0x1FFFF)) || ((first &gt;= 0x2702) &amp;&amp; (first &lt;= 0x27B0)) || ((first &gt;= 0x1F601) &amp;&amp; (first &lt;= 0x1F64F)));&#125; 这个解决方法可以处理特定的场景，但通用性并不强，需要在多个App的界面下进行过滤操作，这不是我们所想要的完美解决方法，所以接下来看一下第二种解决思路。 2. 重写EditText这个解决思路是在整理这份文章的时候发现的，想着即使没有Google输入法源码，但输入法之类的实现应该跟Input输入系统有关，说不定可以了解到为什么会只删除一个char或者更多信息。奔着这个想法就重新看了下代码，然后惊喜的找到了更好的解决方法！（果然“温故而知新”啊！ 先上一张输入法的框架图： 这张图可以提取一下几点信息（在这里感谢下互联网大牛的无私分享）： 两个过程： 按键消息，由客户端进程接收，如果客户端进程判断当前有输入法窗口，则需要跨进程转交给InputMethod进程触屏消息（触摸在输入法窗口中），由输入法处理，结束后把结果跨进程提交给客户端进程 四个binder： IInputContext：负责InputMethod进程和应用进程的编辑框的通信，如上屏、查询光标前后字符等IInputMethodClient：IMMS使用该接口查找和IMS对应的客户端应用进程，并通知应用进程绑定/解绑输入法。IInputMethodSession：定义了客户端可以调用输入法的相关方法，如updateCursor, finishInput等IInputMethod：负责IMS和IMMS的通信，IMMS通知IMS进行startInput，bindInput等生命周期操作。 出处：https://www.jianshu.com/p/eb4ab57393f3 这里我们只关注第一点 “按键消息，由客户端进程接收，如果客户端进程判断当前有输入法窗口，则需要跨进程转交给InputMethod进程 “，那么在输入法界面按下删除键，会触发什么KeyEvent呢？我们可以对EditText设置OnKeyListener来监听Key事件： 1234567891011editText.setOnKeyListener(new OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; //You can identify which key pressed //by checking keyCode value with KeyEvent.KEYCODE_ if(keyCode == KeyEvent.KEYCODE_DEL) &#123; Log.w(TAG, \"KEYCODE_DEL\"); &#125; return false; &#125;&#125;); 然后会发现，Google输入法按下删除键会触发KEYCODE_DEL，而Google语音输入法则不会触发。输入法删除字符时会触发到InputConnection的deleteSurroundingText方法（参考），而InputConnection的创建是在View的onCreateInputConnection方法中实现。 由上可知，删除的操作都围绕着 InputConnection 这个类来进行，那么我们就可以通过重写EditText类的onCreateInputConnection方法，创建自己的InputConnection来适配当前的问题场景，让EditText在执行删除操作时发送KEYCODE_DEL事件，响应OnKeyListener事件，问题就得到解决了。 以下是参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MyCompatEditText extends EditText &#123; private static final String TAG = MyCompatEditText.class.getSimpleName(); public MyCompatEditText(Context context) &#123; super(context); &#125; public MyCompatEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyCompatEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public InputConnection onCreateInputConnection(EditorInfo outAttrs) &#123; return new CompatInputConnection(super.onCreateInputConnection(outAttrs), true); &#125; private class CompatInputConnection extends InputConnectionWrapper &#123; CompatInputConnection(InputConnection target, boolean mutable) &#123; super(target, mutable); &#125; @Override public boolean sendKeyEvent(KeyEvent event) &#123; Log.d(TAG, \"sendKeyEvent keyCode=\" + event.getKeyCode() + \", action=\" + event.getAction()); return super.sendKeyEvent(event); &#125; @Override public boolean deleteSurroundingText(int beforeLength, int afterLength) &#123; Log.d(TAG, \"deleteSurroundingText beforeLength=\" + beforeLength + \", afterLength=\" + afterLength); if (beforeLength == 1 &amp;&amp; afterLength == 0) &#123; // in latest Android, deleteSurroundingText(1, 0) will be called for backspace // 删除emoji表情时，beforeLength == 1 afterLength == 0 sendDownUpKeyEventForBackwardCompatibility(KeyEvent.KEYCODE_DEL); return true; &#125; // 如果去掉上面新增的内容，默认就是走的这里， // 就会出现我们所说的emoji只删除一个char，且无法响应OnKeyListener事件 return super.deleteSurroundingText(beforeLength, afterLength); &#125; /** * 发送 KEYCODE_DEL 事件 */ private void sendDownUpKeyEventForBackwardCompatibility(final int code) &#123; final long eventTime = SystemClock.uptimeMillis(); sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL)); // 这里一定要发送ACTION_UP来通知Input系统事件结束， // 否则会在InputEventConsistencyVerifier的onKeyEvent方法中 // 报出\"ACTION_DOWN but key is already down and this event is not a key repeat.\" // 这是不正常的情况 sendKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL)); &#125; &#125;&#125; 思路来自： Stack Overflow：Android EditText delete(backspace) key event cnblogs：图解Android - Android GUI 系统 (5) - Android的Event Input System 注：EditText中Google原生键盘、华为P9等部分机型上出现的 del键无法响应OnKeyListener事件，也是同样的解法。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://yoursite.com/tags/Android系统/"}]},{"title":"多线程和虚拟机","slug":"多线程和虚拟机","date":"2018-01-12T02:56:01.000Z","updated":"2018-01-12T03:07:01.154Z","comments":true,"path":"2018/01/12/多线程和虚拟机/","link":"","permalink":"http://yoursite.com/2018/01/12/多线程和虚拟机/","excerpt":"之前在网上看到的一些关于虚拟机和线程的讲解，讲得比较的通俗易懂，在这里做个整理，方便以后查看。其实理解下来，这些信息都能联系到之前在大学上的操作系统这门课，虚拟机、线程、cpu运行等等，这样理解和延伸就变容易很多了。（现在很后悔当时没好好听课啊。。）","text":"之前在网上看到的一些关于虚拟机和线程的讲解，讲得比较的通俗易懂，在这里做个整理，方便以后查看。其实理解下来，这些信息都能联系到之前在大学上的操作系统这门课，虚拟机、线程、cpu运行等等，这样理解和延伸就变容易很多了。（现在很后悔当时没好好听课啊。。） 虚拟机Java程序运行在虚拟机上，而虚拟机又与操作系统打交道，最终通过二进制指令操纵电子电路运行，完成数据的读取、存储、运算和输出。 虚拟机在加载.class文件是，会在内存开辟一块区域“方法区”，专门用来存储类的基本信息，同时在“堆”区为这些类生成一个Class对象，作为类的镜像或模具，为反射提供基础。程序运行过程中，对象不断地生成和死亡，有的朝生暮死（大部分对象，例如方法内部生成的临时对象），有的壮年而亡，有的长命百岁，有的长生不死除非世界毁灭（虚拟机关闭）。对象生要吃喝死了要埋，所以虚拟机需要不停得去申请内存、回收内存。对象的生成方法有很多，new、反射等，对象回收的方法也很多，GC回收、标记-清除、复制、标记-整理等等。 垃圾回收，首先我们要知道什么是垃圾、为什么产生、如何回收。我所理解简单的垃圾回收，是后台启动一个线程，设置一定条件（间隔时间、资源阈值等），达到后扫描垃圾对象并清除，然后继续执行原来的程序。如果要更深层的研究，则需要考虑到效率、安全性等因素。举个例子： 对象生命周期不同，使用同一种回收机制（例如设置间隔时间）这样处理的效率是非常低的，对原程序的运行也会有不可预知的影响。那么我们可以这么改进： 根据对象的生命周期不同作为一个特性，用来划分不同的运行堆区，每个区采用不同的清理算法； 根据多核特性，启动多个回收线程一起跑； 由上述的内容，虚拟机优化就有两个大方向：各个区的大小如何最优划分、GC回收算法如何选择最优，映射到技术层面就是JVM参数调整。 多线程程序运行的时候，占有cpu和内存资源，而cpu运算的时候需要从内存（很多时候是缓存）取值，然后放入寄存器参与运算，得到结果后先放入寄存器，再放回内存。程序执行的指令集也在放在寄存器中，它记录了当前程序执行的地址。一句话概括就是：程序=数据结构+算法。 线程执行是语言指令寄存器的，也就是当你切换线程的时候，需要从虚拟机的程序计数器（PC）把该线程的执行指令放到寄存器，当然线程涉及的其他资源也要切换，例如IO设备。这些都是需要耗费资源的，也就是常说的线程的上下文切换。cpu在执行程序的时候，需要准备程序执行指令所需的寄存器的值，以及所涉及的设备（文件系统、网络资源等），所以说线程创建是一个很大的开销，这也就解释了线程是cpu执行的最小单位了。 延伸一个问题，为什么单线程比多线程快？如上所述线程创建时cpu会分配资源，切换线程时其他资源也需要切换，在单线程模式下，资源都是线程本身的，不存在与其他线程共享与竞争其他资源的情况。 Java Thread的start方法和run方法的区别由上述关于多线程的内容可知，start方法会在线程开始执行的时候准备线程所需的资源，而run方法则是相当于普通的方法调用，程序依然运行在主线程中。因此在多线程应用中，调用start方法后，线程必须的资源虚拟机会自动分配，我们所需要关心的只是告诉线程我们想做什么。 从此我们可以延伸出实现线程的方式： 继承Thread，重写run方法； 实现Runnable接口，实现run方法； 实现Callable接口，回调获取线程结果； 方法1使用了继承，方法2、3使用了组合，内部持有了所需实现的类，会让程序更加灵活。（这里可以对应到“多用组合少用继承”的开发原则）。 synchronized关键字与同步机制一个数值，进入cpu运算，需要经过内存-&gt;多级缓存-&gt;寄存器。当多线程运算同一个数值是，需要把值从主内存拿到该线程工作的内存单元（寄存器）中，当一个线程计算完毕（CPU会优先把计算结果放到寄存器），还没来得及将数值刷新到主内存，这时候其他线程从主内存取到的是旧值。JVM运行的每个线程都有自己的线程栈，不同线程运行时，都需要复制主内存的一份副本到自身的工作内存。如何保证每个线程拿到的数据都是最新的，这就是同步机制。 synchronized关键字就是给数据上个锁，共享变量同一时刻只允许一个线程去操作，其他线程必须等待锁释放后才可以进入。这里可以联系到上厕所模型，然后就可以延伸出锁的类型了。 但有些时候，我们不关心共享值在被谁操作，我们只关心这个值当前是什么。所以就有了volatile。很多博客对该关键词的描述是：保证可见性，不保证原子性。我们来拆解（拆分理解）一下这句话。 一个共享变量声明为volatile，等于告诉虚拟机控制所有的线程：这个变量有点帅，要请他需要他的老家（主内存）来，回来时也要尽快送回去。所以，CPU计算时从主内存取值，计算完毕后直接存入主内存，不会写到缓存了。这就是所谓的“可见性”，这个值当前是什么，我们是完全知道的。至于原子性，由上可知谁都可以取值来进行运算。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Camera1架构和ASD流程源码分析","slug":"Camera1架构和ASD流程源码分析","date":"2018-01-12T01:46:32.000Z","updated":"2018-01-16T03:14:10.124Z","comments":true,"path":"2018/01/12/Camera1架构和ASD流程源码分析/","link":"","permalink":"http://yoursite.com/2018/01/12/Camera1架构和ASD流程源码分析/","excerpt":"","text":"相关文件路径 Java层:/vendor/mediatek/proprietary/packages/apps/Camera/src/ /com/mediatek/camera/AdditionManager.java /com/mediatek/camera/addition/Asd.java /com/android/camera/CameraManager.java /com/android/camera/AndroidCamera.java framework层：/frameworks/av/camera/Camera.cpp/frameworks/av/camera/CameraBase.cpp/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp/frameworks/av/services/camera/libcameraservice/mediatek/api1/CameraClient.cpp/frameworks/base/core/java/android/hardware/Camera.java jni层： /frameworks/base/core/jni/android_hardware_Camera.cpp Hardware层：vendor/mediatek/proprietary/hardware/mtkcam/ legacy/platform/mt6735/core/featureio/pipe/aaa/Hal3AAdapter1.cpp legacy/platform/mt6735/core/featureio/pipe/asd/asd_hal_base.cpp legacy/platform/mt6735/core/featureio/pipe/asd/asd/asd_hal.cpp legacy/platform/mt6735/v1/client/CamClient/FD/Asd/AsdClient.cpp legacy/platform/mt6735/v1/client/CamClient/FD/FDClient.Thread.cpp main/hal/device1/common/Cam1DeviceBase.cpp legacy/v1/client/CamClient/CamClient.cpp 1. 引言最近遇到了ASD(自动场景检测)在室内光线较好的情况下，会选择到夜间模式，需要调整其阈值。于是分析了MTK平台对于Camera1架构的源码实现流程，梳理了ASD的工作流程(App-&gt;framework-&gt;jni-&gt;HAL)，但也仅是对源码流程的一个贯穿，没有对具体实现深入分析。以后若有时间进一步学习，再做补充。 分析思路： 先以设置里打开ASD开关为触发点，预览界面/场景检测结果更新为截止点，抓取camera的mtklog； 检索log的关键信息，找到App层的入口，分析在上层及framework层所做的操作； 检索log的关键信息，找到HAL层的入口，分析在HAL层的事件处理以及消息传递； 结合2和3的分析结果，分析framework层与HAL层的jni通信； 2. 架构camera架构图如下： 应用框架应用代码位于应用框架级别，它利用 android.hardware.Camera API 来与相机硬件互动。在内部，此代码会调用相应的 JNI 粘合类，以访问与该相机互动的原生代码。 JNI与 android.hardware.Camera 关联的 JNI 代码位于 frameworks/base/core/jni/android_hardware_Camera.cpp。此代码会调用较低级别的原生代码以获取对物理相机的访问权限，并返回用于在框架级别创建 android.hardware.Camera 对象的数据。 原生框架在 frameworks/av/camera/Camera.cpp 中定义的原生框架可提供相当于 android.hardware.Camera 类的原生类。此类会调用 IPC binder 代理，以获取对相机服务的访问权限。 Binder IPC 代理IPC binder 代理有助于越过进程边界实现通信。调用相机服务的 frameworks/av/camera 目录中有 3 个相机 binder 类。ICameraService 是相机服务的接口，ICamera 是已打开的特定相机设备的接口，ICameraClient 是返回应用框架的设备接口。 相机服务位于 frameworks/av/services/camera/libcameraservice/CameraService.cpp 下的相机服务是与 HAL 进行互动的实际代码。 HAL硬件抽象层定义了由相机服务调用且您必须实现以确保相机硬件正常运行的标准接口。 内核驱动程序相机的驱动程序可与实际相机硬件和您的 HAL 实现进行互动。相机和驱动程序必须支持 YV12 和 NV21 图片格式，以便在显示和视频录制时支持预览相机图片。 以上信息引用自：https://source.android.com/devices/camera/ 。接下来顺着Camera1的纵线流程来分析MTK平台上ASD是如何工作的。 3. 启动流程(App、Framework层)3.1 启动流程图 接下来，从源码来说说这个流程图。 3.2 AdditionManager.java1234567891011121314151617181920public void onCameraParameterReady(boolean isMode) &#123; // 参数变化时会调用到这里 Log.i(TAG, \"[onCameraParameterReady]isMode = \" + isMode); Vector&lt;ICameraAddition&gt; curAddition = mModeAddition; if (!isMode) &#123; curAddition = mNormalAddition; &#125; for (ICameraAddition addition : curAddition) &#123; // Asd继承自CameraAddition // 在这里判断Asd开关是否支持&amp;打开 boolean isSupport = addition.isSupport(); boolean isOpen = addition.isOpen(); if (isSupport &amp;&amp; !isOpen) &#123; // 如果支持且开关已打开，则调用Asd的open方法打开Asd模式 addition.open(); &#125; else if (!isSupport &amp;&amp; isOpen) &#123; addition.close(); &#125; &#125;&#125; 3.3 Asd.java12345678910111213141516171819@Overridepublic void open() &#123; Log.d(TAG, \"[open]...\"); startAsd();&#125;public void startAsd() &#123; Log.i(TAG, \"[startAsd]...\"); // 更新当前camera设备实例 updateCameraDevice(); if (mICameraDevice == null) &#123; return; &#125; // 这里通知framework层做Asd Callback的初始化和设置 // 用来接收来自HAL层的消息 mICameraDevice.setAsdCallback(mASDCaptureCallback); // 更新ASD状态 mCurrentState = AsdState.STATE_OPENED;&#125; 3.4 CameraManager.java1234567891011121314151617181920212223@Overridepublic void setAsdCallback(AsdListener asdListener) &#123; // 创建AsdListener实例 mCameraDevice.setAsdCallback(asdListener == null ? null : new AsdListenerImpl(asdListener));&#125;public void setAsdCallback(AsdCallback asdCallback) &#123; // 通知内部类CameraHandler，设置AsdCallback mCameraHandler.obtainMessage(SET_ASD_CALLBACK, asdCallback).sendToTarget(); waitDone();&#125;private class CameraHandler extends Handler &#123; @Override public void handleMessage(final Message msg) &#123; ... case SET_ASD_CALLBACK: // 这里mCamera是ICamera实例，接口在AndroidCamera中实现 mCamera.setAsdCallback((AsdCallback) msg.obj); return; ... &#125;&#125; 3.5 AndroidCamera.java1234public void setAsdCallback(AsdCallback cb) &#123; // 调用Camera1接口设置Asd的回调 mCamera.setAsdCallback(cb);&#125; 3.6 android.hardware.Camera.java1234567891011/** * @hide * @internal * * Registers a callback to be invoked when auto scene is detected * @param cb the callback to run */public final void setAsdCallback(AsdCallback cb) &#123; // 设置framework层的AsdCallback回调实例 mAsdCallback = cb;&#125; 3.7 AsdCallback的创建12345678910111213141516// Asd.java的内部类，实现了AsdListener接口// 用于接收来自HAL层的消息，然后通知camera ui做出相应处理private final AsdListener mASDCaptureCallback = new AsdListener() &#123; public void onDeviceCallback(int scene) &#123; Log.i(TAG, \"[onDeviceCallback] onDetected scene = \" + scene + \",\" + \"mLastScene:\" + mLastScene); if (mLastScene != scene) &#123; boolean suggestedHdr = (scene == SCENE_BACK_LIGHT || scene == SCENE_BACK_LIGHT_PORTRAIT); // 通知camera ui场景的选择结果 mICameraAppUi.onDetectedSceneMode(scene, suggestedHdr); mLastScene = scene; &#125; &#125;&#125;; 4. 处理流程及消息回调(Hardware层)下面主要讲述在Hardware层，Asd是如何初始化其Client，然后根据camera设备提供的信息进行场景选择，将结果返回给framework层的Camera1，随后传递到上层Camera app的。首先来看看流程图。 4.1 处理流程图 4.2 Hardware层文件说明 FDClient、AsdClient.cpp : Camera的每个feature好像都有一个专属的Client，每个Client又有专属的Client.Thead线程用来处理各类事件；而Asd的场景列表中有人脸模式（在后续的scene decider时也传入了facenum这样的参数）。这里没有进行深入研究，这里就先暂不拓展，因为整个camera架构还是很大的Orz asd_hal.cpp : 该流程的核心成员，主要功能是halASD实例的创建与销毁、ASD的初始化、场景选择。MTK在这里进行ASD各场景的阈值设置，同时分离了一个客制化的配置文件camera_custom_asd.h，客户可在HalAsdInit初始化的时候读取该客制化文件的值，从而客制化修改ASD场景的阈值； CameraClient.cpp : 用以接收来自AsdClient的回调消息； Camera.cpp : 上报回调消息到jni层； android_hardware_Camera.cpp : jni层的实现 4.3 FD.Client.Thread.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// PreviewClient的state发生变化时会发送eID_WAKEUP消息// FDClient应该也会接收到，这里没去细看bool FDClient::threadLoop()&#123; Command::EID cmd; if ( getCommand(cmd) ) &#123; switch (cmd) &#123; case Command::eID_WAKEUP: // 初始化一些Client onClientThreadLoop(); break; // case Command::eID_EXIT: default: MY_LOGD(\"Command::%d\", cmd); break; &#125; &#125; ...&#125;void FDClient::onClientThreadLoop()&#123; ... #if (1 == AUTO_SCENE_DETECT_SUPPORT) //ASD Init // 创建AsdClient实例 mpASDClient = IAsdClient::createInstance(mpParamsMgr); // 调用AsdClient的init方法初始化AsdClient if ( mpASDClient == 0 || ! mpASDClient-&gt;init() ) &#123; MY_LOGE(\"mpASDClient init failed\"); &#125; // 设置回调 mpASDClient-&gt;setCallbacks(mpCamMsgCbInfo); #endif //(3) Do in loop until stopFaceDetection has been called // either by sendCommand() or by stopPreview() while ( isEnabledState() ) &#123; ... if (mpFDHalObj != NULL) &#123; // (3.4) //performCallback(isDetected_FD, isDetected_SD); performCallback(isDetected_FD, isDetected_SD, isDetected_GD); #if (1 == AUTO_SCENE_DETECT_SUPPORT) //Call ASD if doFD if(isMsgEnabled()) &#123; int FaceNum = mpFDHalObj-&gt;halFDGetFaceResult(mpDetectedFaces); // 进行更新操作 // 这里开始进入到AsdClient的流程(场景选择/消息回调) mpASDClient-&gt;update(DDPBuffer, srcWidth, srcHeight, FaceNum); &#125; #endif &#125; ... &#125; ... #if (1 == AUTO_SCENE_DETECT_SUPPORT) if (mpASDClient != 0) &#123; mpASDClient-&gt;uninit(); mpASDClient = NULL; &#125; #endif ...&#125; 4.4 AsdClient.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788voidAsdClient::update(MUINT8 * OT_Buffer, MINT32 a_Buffer_width, MINT32 a_Buffer_height, MINT32 a_FaceNum)&#123; MUINT32 u4Scene = 0; ASDInfo_T ASDInfo; bool const isAsdEnabled = mpParamsMgr-&gt;getShotModeStr() == MtkCameraParameters::CAPTURE_MODE_ASD_SHOT; enable(isAsdEnabled); if ( ! isEnabled() ) &#123; return; &#125; //Get 3A Info. MINT32 const i4SensorDevId = 1; //Need to be fixed. i4SensorDevId--&gt; i4SensorDevIdIndex, BinChang 2014/01/13 // 创建一个Hal3AAdapter实例，用以获取ASDInfo mpHal3A = IHal3A::createInstance(NS3A::IHal3A::E_Camera_1, mpParamsMgr-&gt;getOpenId(), LOG_TAG); mpHal3A-&gt;getASDInfo(ASDInfo); if (mpHal3A) &#123; mpHal3A-&gt;destroyInstance(LOG_TAG); &#125; //Get FD Info.#if(0) mpHalFD = halFDBase::createInstance(HAL_FD_OBJ_FDFT_SW); mpHalFD-&gt;halFDGetFaceInfo(mpFaceInfo); if(mpHalFD) &#123; mpHalFD-&gt;destroyInstance(); &#125;#endif //Asd Pipe Init. // 初始化Asd管道 if(mpHalASDObj == NULL) &#123; //Set Frame: Prepare QVGA RGB565 resolution if(a_Buffer_width*3 == a_Buffer_height*4) Buffer_height = 240; else if(a_Buffer_width*9 == a_Buffer_height*16) Buffer_height = 180; else if(a_Buffer_width*3 == a_Buffer_height*5) Buffer_height = 192; else Buffer_height = 240; // 创建halAsd实例 mpHalASDObj = halASDBase::createInstance(HAL_ASD_OBJ_AUTO); if(mpHalASDObj == NULL) &#123; MY_LOGE(\"mpHalASDObj createInstance fail\"); &#125; // 初始化halAsd实例，这里传入了一个ASDInfo，里面是AWB的一些信息 // 参数的客制化修改也是在这里进行 mpHalASDObj-&gt;mHalAsdInit((void*)&amp;ASDInfo, mpWorkingBuf, (eSensorType==SENSOR_TYPE_RAW)?0:1, Buffer_width/2, Buffer_height/2); &#125; //Asd Pipe Decider // 开始场景检测，这里交由mtk封装的camera算法lib库文件处理，结果是返回到mSceneCur // 注意这里还传入了一个参数a_FaceNum，所以说FDClient跟AsdClient是有关联的 mpHalASDObj-&gt;mHalAsdDecider((void*)&amp;ASDInfo, a_FaceNum ,mSceneCur); //MY_LOGD(\"ASDInfo.bAEBacklit:%d \", ASDInfo.bAEBacklit); //MY_LOGD(\"mSceneCur:%d \", mSceneCur); u4Scene = mSceneCur; MY_LOGD(\"u4Scene:%d \", u4Scene); if (1) &#123; // 消息处理，通知回调函数 // 这里的mNotifyDb回调函数是在CameraClient的initialize函数里设置了 // 对应CameraClient的notifyCallback函数，下面的CameraClient章节会说明一下这部分 mpCamMsgCbInfo-&gt;mNotifyCb( MTK_CAMERA_MSG_EXT_NOTIFY, //msgType MTK_CAMERA_MSG_EXT_NOTIFY_ASD, //ext1 u4Scene, //ext2 mpCamMsgCbInfo-&gt;mCbCookie ); &#125; //MY_LOGD(\"Buffer_width:%d, Buffer_height:%d,\", Buffer_width, Buffer_height); // 场景选择后的处理，这里主要是做了一些缓存区的申请 mpHalASDObj-&gt;mHalAsdDoSceneDet((void*)OT_Buffer, Buffer_width, Buffer_height);&#125; 4.5 asd_hal.cppAsd初始化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364MINT32 halASD::mHalAsdInit(void* AAAData,void* working_buffer,MUINT8 SensorType, MINT32 Asd_Buf_Width, MINT32 Asd_Buf_Height)&#123; ASD_Customize_PARA1 ASDThres1; //客制化参数集1 ASD_Customize_PARA2 ASDThres2; //客制化参数集2 g_udCount++; MY_LOGD(\"[halASD] g_udCount++:%d \\n\", g_udCount); AAA_ASD_PARAM* rASDInfo=(AAA_ASD_PARAM*)AAAData; MINT32 Retcode = S_ASD_OK; MUINT32* AFtable=(MUINT32*)malloc((rASDInfo-&gt;i4AFTableIdxNum + 1)*sizeof(MUINT32)); // debug开关，可通过设置property来打开，从而查看更多log信息 char value[PROPERTY_VALUE_MAX] = &#123;'\\0'&#125;; property_get(\"ASD.debug.dump\", value, \"0\"); mHalASDDumpOPT = atoi(value); gMyAsdInitInfo.pInfo = &amp;gMyAsdEnvInfo; gMyAsdInitInfo.pDeciderInfo = &amp;gMyDeciderEnvInfo; gMyAsdInitInfo.pDeciderTuningInfo = &amp;gMyDeciderTuningInfo; ... //这里省略的代码是做gMyAsdInitInfo的一些初始化操作，其中比较关键的是pDeciderInfo的初始化 //主要是3A中的AWB、AF信息的获取和赋值 ... //这里将pDeciderInfo的指针地址赋值为0了，使用mtk camera算法底层库的默认册数 //如果需要对ASD的的参数进行客制化修改，需要注释掉这里 //不然在客制化赋值的时候会找不到正确的内存地址，而导致修改无效 gMyAsdInitInfo.pDeciderTuningInfo = 0; // use default value ... /* Create MTKPano Interface */ //m_pMTKAsdObj用于调用底层库方法 if(m_pMTKAsdObj == NULL) &#123; m_pMTKAsdObj = MTKAsd::createInstance(DRV_ASD_OBJ_SW); MY_LOGW_IF(m_pMTKAsdObj == NULL, \"Err\"); &#125;//客制化参数的获取和设置//if (0)默认不编译，如果需要进行客制化修改，这里需要改成if (1)#if (0) //从camera_custom.h中获取客制化参数集 get_asd_CustomizeData1(&amp;ASDThres1); get_asd_CustomizeData2(&amp;ASDThres2); //客制化参数设置 gMyAsdInitInfo.pDeciderTuningInfo-&gt;IdxWeightBlAe = ASDThres2.s2IdxWeightBlAe; ... gMyAsdInitInfo.pDeciderTuningInfo-&gt;EvLoThrNight = ASDThres2.s2EvLoThrNight; gMyAsdInitInfo.pDeciderTuningInfo-&gt;EvHiThrNight = ASDThres2.s2EvHiThrNight; ... gMyAsdInitInfo.pDeciderTuningInfo-&gt;ScoreThrNight = ASDThres1.u1ScoreThrNight; ...#endif //初始化Asd m_pMTKAsdObj-&gt;AsdInit(&amp;gMyAsdInitInfo, 0); if (AFtable) &#123; free(AFtable); &#125; return Retcode;&#125; Asd场景检测：123456789101112131415161718192021222324252627MINT32 halASD::mHalAsdDecider(void* AAAData,MINT32 Face_Num,mhal_ASD_DECIDER_UI_SCENE_TYPE_ENUM &amp;Scene)&#123; MINT32 Retcode = S_ASD_OK; AAA_ASD_PARAM* rASDInfo=(AAA_ASD_PARAM*)AAAData; ASD_DECIDER_RESULT_STRUCT MyDeciderResult; ASD_SCD_RESULT_STRUCT gMyAsdResultInfo; ASD_DECIDER_INFO_STRUCT gMyDeciderInfo; ... //设置gMyDeciderInfo的Fd(人脸检测)、3A(AE&amp;AWB&amp;AF)信息 ... // 这里的m_pMTKAsdObj在Asd init的时候创建了，用以调用MTK底层库封装的函数 // AsdFeatureCtrl、AsdMain这两个函数的实现是在/vendor/xxx/libs中 // 可以通过 grep 关键字 来检索 m_pMTKAsdObj-&gt;AsdFeatureCtrl(ASD_FEATURE_GET_RESULT, 0, &amp;gMyAsdResultInfo); memcpy(&amp;(gMyDeciderInfo.InfoScd),&amp;gMyAsdResultInfo, sizeof(ASD_SCD_RESULT_STRUCT)); m_pMTKAsdObj-&gt;AsdMain(ASD_PROC_DECIDER, &amp;gMyDeciderInfo); m_pMTKAsdObj-&gt;AsdFeatureCtrl(DECIDER_FEATURE_GET_RESULT, 0, &amp;MyDeciderResult); MY_LOGD(\"[mHalAsdDecider] detect Scene is %d, Face Num:%d \\n\",MyDeciderResult.DeciderUiScene, gMyDeciderInfo.InfoFd.FdFaceNum); // 得到场景检测的结果 Scene=(mhal_ASD_DECIDER_UI_SCENE_TYPE_ENUM) MyDeciderResult.DeciderUiScene; //Scene=mhal_ASD_DECIDER_UI_AUTO; return Retcode;&#125; 4.6 CameraClient.cpp首先先来说说AsdClient中提到的mNotifyCb函数，这个函数是在CameraClient的initialize函数中被定义的。我们来看看代码：1234567891011status_t CameraClient::initialize(CameraModule *module) &#123; ... mHardware = new CameraHardwareInterface(camera_device_name); ... //调用的是Cam1DeviceBase的setCallback()函数 mHardware-&gt;setCallbacks(notifyCallback, dataCallback, dataCallbackTimestamp, (void *)(uintptr_t)mCameraId); ...&#125; 接下来我们看看Cam1DeviceBase setCallback函数的实现： 1234567891011121314151617181920212223242526272829303132// Set the notification and data callbacksvoid Cam1DeviceBase::setCallbacks( camera_notify_callback notify_cb, //notify Callback函数 camera_data_callback data_cb, //data Callback函数 camera_data_timestamp_callback data_cb_timestamp, camera_request_memory get_memory, void*user)&#123; mpCamMsgCbInfo-&gt;mCbCookie = user; mpCamMsgCbInfo-&gt;mNotifyCb = notify_cb; //mNotifyCb函数赋值 mpCamMsgCbInfo-&gt;mDataCb = data_cb; //mDataCb函数赋值 mpCamMsgCbInfo-&gt;mDataCbTimestamp= data_cb_timestamp; mpCamMsgCbInfo-&gt;mRequestMemory = get_memory; // if ( mpCamClient != 0 ) &#123; mpCamClient-&gt;setCallbacks(mpCamMsgCbInfo); &#125; // forward to registered clients Vector&lt;sp&lt;ICamClient&gt; &gt;::const_iterator it; for (it = vmpCamClient.begin(); it != vmpCamClient.end(); ++it) &#123; (*it)-&gt;setCallbacks(mpCamMsgCbInfo); &#125; // if ( mpCamAdapter != 0 ) &#123; mpCamAdapter-&gt;setCallbacks(mpCamMsgCbInfo); &#125;&#125; 刚才我们分析到AsdClient在进行场景检测得到结果后，调用了mNotifyCb函数；根据上面的分析，mNotifyCb函数指向CameraClient的notifyCallback函数，来看看该函数的代码： 1234567891011121314151617181920212223242526272829303132333435363738// Callback messages can be dispatched to internal handlers or pass to our// client's callback functions, depending on the message type.//// notifyCallback:// CAMERA_MSG_SHUTTER handleShutter// (others) c-&gt;notifyCallback// dataCallback:// CAMERA_MSG_PREVIEW_FRAME handlePreviewData// CAMERA_MSG_POSTVIEW_FRAME handlePostview// CAMERA_MSG_RAW_IMAGE handleRawPicture// CAMERA_MSG_COMPRESSED_IMAGE handleCompressedPicture// (others) c-&gt;dataCallback// dataCallbackTimestamp// (others) c-&gt;dataCallbackTimestampvoid CameraClient::notifyCallback(int32_t msgType, int32_t ext1, int32_t ext2, void* user) &#123; LOG2(\"notifyCallback(%d)\", msgType); sp&lt;CameraClient&gt; client = static_cast&lt;CameraClient*&gt;(getClientFromCookie(user).get()); if (client.get() == nullptr) return; if (!client-&gt;lockIfMessageWanted(msgType)) return; switch (msgType) &#123; //!++ case MTK_CAMERA_MSG_EXT_NOTIFY: client-&gt;handleMtkExtNotify(ext1, ext2); // Callback extended msg notification. break; //!-- case CAMERA_MSG_SHUTTER: // ext1 is the dimension of the yuv picture. client-&gt;handleShutter(); break; default: client-&gt;handleGenericNotify(msgType, ext1, ext2); break; &#125;&#125; mNotifyCb函数调用传入的msgType是MTK_CAMERA_MSG_EXT_NOTIFY ，那么接下来会执行到handleMtkExtNotify，该函数在Mediatek自己写的CameraClient.cpp中实现。12345678910111213141516171819202122232425262728void CameraClient::handleMtkExtNotify(int32_t ext1, int32_t ext2)&#123; int32_t const extMsgType = ext1; switch (extMsgType) &#123; case MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE: handleMtkExtCaptureDone(ext1, ext2); break; // case MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER: handleMtkExtShutter(ext1, ext2); break; // case MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER: handleMtkExtBurstShutter(ext1, ext2); break; case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER: handleMtkExtContinuousShutter(ext1, ext2); break; case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END: handleMtkExtContinuousEnd(ext1, ext2); break; // default: handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2); break; &#125;&#125; 传入的ext1为MTK_CAMERA_MSG_EXT_NOTIFY_ASD，所以又走回Android原生 CameraClient 的handleGenericNotify函数：1234567891011121314151617181920212223242526void CameraClient::handleGenericNotify(int32_t msgType, int32_t ext1, int32_t ext2) &#123; //!++ #ifdef MTK_CAM_FRAMEWORK_DEFAULT_CODE //!-- sp&lt;hardware::ICameraClient&gt; c = mRemoteCallback; //!++ #else sp&lt;hardware::ICameraClient&gt; c; &#123; Mutex::Autolock remoteCallbacklock(mRemoteCallbackLock); c = mRemoteCallback; &#125; #endif //!-- //!++ There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed. #ifdef MTK_CAM_FRAMEWORK_DEFAULT_CODE mLock.unlock(); #endif //!-- // 除了notifyCallback这种方式，在看Preview流程时还有一种方式是 // copy当前帧然后把copy后的数据直接发送出去 if (c != 0) &#123; c-&gt;notifyCallback(msgType, ext1, ext2); &#125;&#125; 由上可知消息是通过12sp&lt;hardware::ICameraClient&gt; c = mRemoteCallback; c-&gt;notifyCallback(msgType, ext1, ext2); 的方式发送出去的。 那这个mRemoteCallback又是在哪里初始化的呢？检索了一下，是在CameraClient::connect中被赋值了，继续跟踪下去，会发现是在CameraClient的构造函数里初始化的，这里涉及到了多层继承(CameraClient-&gt;CameraService-&gt;Client)，看看代码：1234567891011121314151617181920212223242526272829303132333435step1：CameraClient::CameraClient(const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;hardware::ICameraClient&gt;&amp; cameraClient, // 这里传入了一个ICameraClient const String16&amp; clientPackageName, int cameraId, int cameraFacing, int clientPid, int clientUid, int servicePid, bool legacyMode): // 这里开始调用Client的构造函数，传入一个cameraClient参数 // Client是CameraService底下的一个内部类 Client(cameraService, cameraClient, clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid) step2：CameraService::Client::Client(const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;ICameraClient&gt;&amp; cameraClient, const String16&amp; clientPackageName, int cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid) : CameraService::BasicClient(cameraService, IInterface::asBinder(cameraClient), clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid)&#123; int callingPid = getCallingPid(); LOG1(\"Client::Client E (pid %d, id %d)\", callingPid, cameraId); // 这里对mRemoteCallback进行了赋值初始化 mRemoteCallback = cameraClient; cameraService-&gt;loadSound(); LOG1(\"Client::Client X (pid %d, id %d)\", callingPid, cameraId);&#125; 那么思路就清晰了，我们只需要看一下这个CameraClient进行了初始化就可以了。从Camera的connect方法看一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253step 1：sp&lt;Camera&gt; Camera::connect(int cameraId, const String16&amp; clientPackageName, int clientUid, int clientPid)&#123; // CameraBaseT在CameraBase中被定义：typedef CameraBase&lt;TCam&gt; CameraBaseT // CameraBase在Camera被初始化为CameraBase&lt;Camera&gt;，所以上面就相应于调用了 // CameraBase&lt;Camera&gt;::connect() return CameraBaseT::connect(cameraId, clientPackageName, clientUid, clientPid);&#125;step 2：template &lt;typename TCam, typename TCamTraits&gt;sp&lt;TCam&gt; CameraBase&lt;TCam, TCamTraits&gt;::connect(int cameraId, const String16&amp; clientPackageName, int clientUid, int clientPid)&#123; ALOGV(\"%s: connect\", __FUNCTION__); // 构造Camera实例 sp&lt;TCam&gt; c = new TCam(cameraId); // TCamCallbacks在Camera.h中被定义为ICameraClient // 这里cl = c被赋值为Camera类型，而Camera继承了ICameraClient sp&lt;TCamCallbacks&gt; cl = c; const sp&lt;::android::hardware::ICameraService&gt; cs = getCameraService(); binder::Status ret; if (cs != nullptr) &#123; // fnConnectService在Camera被初始化为ICameraService::connect() TCamConnectService fnConnectService = TCamTraits::fnConnectService; // 这里调用了CameraService::connect() c和cl是同一个值，做为两个不同的参数传进了 // CameraService::connect() ret = (cs.get()-&gt;*fnConnectService)(cl, cameraId, clientPackageName, clientUid, clientPid, /*out*/ &amp;c-&gt;mCamera); &#125; ... return c;&#125;step 3：// CameraService::connec()构造了一个CameraClient(),又是一个CameraClient，// 但是和上面的ICameraClient没有半毛线关系。只是名字相似,真的是一万个++泥马在奔腾。status_t CameraService::connect(const sp&lt;ICameraClient&gt;&amp; cameraClient, int cameraId, const String16&amp; clientPackageName, int clientUid, /*out*/sp&lt;ICamera&gt;&amp; device) &#123; // CameraService::connect()就做了两件事情 // 初始化Camera里的mCamera和把Camera(参数cameraClient为Camera类型)传给CameraClient // 由上面的分析我们知道CameraClient的构造函数最后会走到CameraService中的Client构造函数 // 所以说，Camera类就是mRemoteCallback client = new CameraClient(this, cameraClient, clientPackageName, cameraId, facing, callingPid, clientUid, getpid()); device = client; return OK;&#125; 所以，使用的c-&gt;notifyCallback调用的是Camera::notifyCallback。123456789101112131415161718// callback from camera servicevoid Camera::notifyCallback(int32_t msgType, int32_t ext1, int32_t ext2)&#123; return CameraBaseT::notifyCallback(msgType, ext1, ext2);&#125;template &lt;typename TCam, typename TCamTraits&gt;void CameraBase&lt;TCam, TCamTraits&gt;::notifyCallback(int32_t msgType, int32_t ext1, int32_t ext2)&#123; sp&lt;TCamListener&gt; listener; &#123; Mutex::Autolock _l(mLock); listener = mListener; &#125; if (listener != NULL) &#123; listener-&gt;notify(msgType, ext1, ext2); &#125;&#125; 这里的mListener是在android_hardware_Camera.cpp被设置，接下来我们进入到JNI层(终于快到Java层了^^)。 5. 消息上报(jni层)首先我们先看一下mListener的设置代码： 1234567static jint android_hardware_Camera_native_setup(...)&#123; sp&lt;Camera&gt; camera; sp&lt;JNICameraContext&gt; context = new MtkJNICameraContext(env, weak_this, clazz, camera); // 设置mListener，类型为MtkJNICameraContext camera-&gt;setListener(context);&#125; 所以listener-&gt;notify调用的是MtkJNICameraContext::notify函数：1234567891011121314void JNICameraContext::notify(int32_t msgType, int32_t ext1, int32_t ext2)&#123; ALOGV(\"notify\"); ... // 这里的post_event在android_hardware_Camera.cpp中有被定义postEventFromNative() // 所以会调用到frameworks/base/core/java/android/hardware/Camera.java的 // postEventFromNative方法 env-&gt;CallStaticVoidMethod(mCameraJClass, fields.post_event, mCameraJObjectWeak, msgType, ext1, ext2, NULL);&#125;jclass clazz = FindClassOrDie(env, \"android/hardware/Camera\");fields.post_event = GetStaticMethodIDOrDie(env, clazz, \"postEventFromNative\", \"(Ljava/lang/Object;IIILjava/lang/Object;)V\"); 那么我们来看一下Camera.java中做了什么操作： 12345678910111213141516171819202122232425262728private static void postEventFromNative(Object camera_ref, int what, int arg1, int arg2, Object obj)&#123; Camera c = (Camera)((WeakReference)camera_ref).get(); if (c == null) return; if (c.mEventHandler != null) &#123; Message m = c.mEventHandler.obtainMessage(what, arg1, arg2, obj); // 这里把hardware层上来的消息发送出去了，在Camera的内部类EventHandler中处理 c.mEventHandler.sendMessage(m); &#125;&#125;private class EventHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; case MTK_CAMERA_MSG_EXT_NOTIFY: case MTK_CAMERA_MSG_EXT_NOTIFY_ASD: if (mAsdCallback != null) &#123; // 这里回调到Asd中声明的AsdCallback里 mAsdCallback.onDetected(msg.arg2); &#125; break; .... &#125;&#125; ok，到这里消息在JNI层是如何被处理、上报到framework再到App就结束了。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://yoursite.com/tags/Android系统/"},{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/tags/Camera/"}]},{"title":"Hello Hexo","slug":"Hello Hexo","date":"2018-01-11T06:34:08.820Z","updated":"2018-01-11T06:47:02.338Z","comments":true,"path":"2018/01/11/Hello Hexo/","link":"","permalink":"http://yoursite.com/2018/01/11/Hello Hexo/","excerpt":"","text":"最近在整理有道笔记的内容，平常都是做伸手党，在互联网各位大神的肩膀上分析/解决问题，于是就想以博客的形式输出一些内容，主要是Android系统源码方面的，希望能在积累沉淀自己的同时，帮助到一些遇到了类似问题的人。可能会偶尔发表自己的一些生活感想，就当是日记记录吧。 作为一个程序员，本着亲自动手的想法，博客当然是想自己搭建了，所以查询了相关资料，折腾了一个上午总算搭建好了。（使用Github + Hexo的方式） 教程链接： Mac Windows Hello Hexo，第一篇章。","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}